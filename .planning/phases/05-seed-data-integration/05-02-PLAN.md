---
phase: 05-seed-data-integration
plan: 05-02
type: execute
---

<objective>
End-to-end testing of complete auth flow and documentation update.

Purpose: Validate the entire authentication system works correctly.
Output: Verified auth flow and updated project documentation.
</objective>

<execution_context>
@~/.Opencode/skills/create-plans/workflows/execute-phase.md
@~/.Opencode/skills/create-plans/templates/summary.md
@~/.Opencode/skills/create-plans/references/checkpoints.md
</execution_context>

<context>
@.planning/BRIEF.md
@.planning/ROADMAP.md
@AUTHENTICATION_DOCUMENTATION.md
@README.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create auth integration test</name>
  <files>api/test_auth_integration.py</files>
  <action>
Create `api/test_auth_integration.py` with pytest tests:

```python
"""
============================================================================
FILE: test_auth_integration.py
LOCATION: api/test_auth_integration.py
============================================================================

PURPOSE:
    Integration tests for authentication endpoints.

USAGE:
    pytest api/test_auth_integration.py -v
============================================================================
"""

import pytest
from fastapi.testclient import TestClient


@pytest.fixture
def client():
    """Create test client with mock database."""
    import os
    os.environ["USE_REAL_FIREBASE"] = "false"
    os.environ["AURA_TEST_MODE"] = "true"
    
    from api.main import app
    return TestClient(app)


class TestLoginEndpoint:
    """Tests for /api/auth/login endpoint."""
    
    def test_login_success_admin(self, client):
        """Admin can login with correct credentials."""
        response = client.post("/api/auth/login", json={
            "email": "admin@test.com",
            "password": "Admin123!"
        })
        assert response.status_code == 200
        data = response.json()
        assert "token" in data
        assert data["user"]["role"] == "admin"
        assert data["token"].startswith("mock-token-admin-")
    
    def test_login_success_staff(self, client):
        """Staff can login with correct credentials."""
        response = client.post("/api/auth/login", json={
            "email": "staff@test.com",
            "password": "Staff123!"
        })
        assert response.status_code == 200
        data = response.json()
        assert data["user"]["role"] == "staff"
        assert data["user"]["departmentId"] is not None
    
    def test_login_invalid_password(self, client):
        """Invalid password returns 401."""
        response = client.post("/api/auth/login", json={
            "email": "admin@test.com",
            "password": "wrongpassword"
        })
        assert response.status_code == 401
    
    def test_login_invalid_email(self, client):
        """Non-existent email returns 401."""
        response = client.post("/api/auth/login", json={
            "email": "nobody@test.com",
            "password": "password"
        })
        assert response.status_code == 401


class TestAuthMeEndpoint:
    """Tests for /api/auth/me endpoint."""
    
    def test_get_me_authenticated(self, client):
        """Authenticated user can get their profile."""
        # First login
        login_response = client.post("/api/auth/login", json={
            "email": "admin@test.com",
            "password": "Admin123!"
        })
        token = login_response.json()["token"]
        
        # Then get profile
        response = client.get("/api/auth/me", headers={
            "Authorization": f"Bearer {token}"
        })
        assert response.status_code == 200
        data = response.json()
        assert data["email"] == "admin@test.com"
        assert data["role"] == "admin"
    
    def test_get_me_unauthenticated(self, client):
        """Unauthenticated request returns 401."""
        response = client.get("/api/auth/me")
        assert response.status_code == 401


class TestRoleProtection:
    """Tests for role-based endpoint protection."""
    
    def test_admin_endpoint_with_admin(self, client):
        """Admin can access admin-only endpoints."""
        # Login as admin
        login_response = client.post("/api/auth/login", json={
            "email": "admin@test.com",
            "password": "Admin123!"
        })
        token = login_response.json()["token"]
        
        # Access users list (admin only)
        response = client.get("/api/users", headers={
            "Authorization": f"Bearer {token}"
        })
        assert response.status_code == 200
    
    def test_admin_endpoint_with_staff(self, client):
        """Staff cannot access admin-only endpoints."""
        # Login as staff
        login_response = client.post("/api/auth/login", json={
            "email": "staff@test.com",
            "password": "Staff123!"
        })
        token = login_response.json()["token"]
        
        # Try to access users list
        response = client.get("/api/users", headers={
            "Authorization": f"Bearer {token}"
        })
        assert response.status_code == 403
```

AVOID: Testing against real Firestore.
WHY: Tests should be hermetic and not require external services.
  </action>
  <verify>cd api && python -m pytest test_auth_integration.py -v 2>&1 | tail -15</verify>
  <done>All auth integration tests pass</done>
</task>

<task type="auto">
  <name>Task 2: Update README.md with authentication section</name>
  <files>README.md</files>
  <action>
Add authentication section to README.md after the "Running the Application" section:

```markdown
## Authentication

The application uses a mock authentication system for local development.

### Test Accounts

| Role | Email | Password |
|------|-------|----------|
| Admin | admin@test.com | Admin123! |
| Staff | staff@test.com | Staff123! |
| Student | student@test.com | Student123! |

### Role Permissions

- **Admin**: Full access to user management, can view all departments
- **Staff**: Can upload notes to assigned department only
- **Student**: Read-only access to assigned department's notes

### Environment Configuration

Set `USE_REAL_FIREBASE=false` in `.env` for mock authentication (default).
Set `USE_REAL_FIREBASE=true` to use real Firebase Authentication.
```

Insert this section appropriately in the existing README structure.

AVOID: Duplicating content from TEST_CREDENTIALS.md.
WHY: README should be a quick reference, detailed info in TEST_CREDENTIALS.md.
  </action>
  <verify>grep -q "Authentication" README.md && echo "Section exists"</verify>
  <done>README.md updated with authentication section</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete authentication system end-to-end</what-built>
  <how-to-verify>
    1. Start backend: `cd api && python -m uvicorn main:app --reload --port 8000`
    2. Start frontend: `cd frontend && npm run dev`
    3. Test login flow:
       - Visit http://localhost:5173 → should redirect to /login
       - Login as admin@test.com / Admin123!
       - Verify you're logged in (user info visible)
       - Test logout button → back to login
    4. Test role protection:
       - Login as staff@test.com / Staff123!
       - Verify staff-appropriate access
       - Try accessing admin-only features (should be blocked)
    5. Test session persistence:
       - Login as any user
       - Refresh the page
       - Verify still logged in
    6. Run integration tests:
       - `cd api && python -m pytest test_auth_integration.py -v`
       - All tests should pass
  </how-to-verify>
  <resume-signal>Type "approved" to complete authentication implementation, or describe issues</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cd api && python -m pytest test_auth_integration.py -v` - all tests pass
- [ ] README.md contains authentication documentation
- [ ] Login flow works end-to-end
- [ ] Role-based protection enforced
- [ ] Session persists across page refresh
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- All integration tests pass
- Documentation updated
- Human verification approved
</success_criteria>

<output>
After completion, create `.planning/phases/05-seed-data-integration/05-02-SUMMARY.md`
</output>
