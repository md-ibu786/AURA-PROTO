---
phase: 04-frontend-auth-ui
plan: 04-02
type: execute
---

<objective>
Create ProtectedRoute component and update App.tsx with route guards.

Purpose: Prevent unauthorized access to protected pages.
Output: Route protection with role-based access control.
</objective>

<execution_context>
@~/.Opencode/skills/create-plans/workflows/execute-phase.md
@~/.Opencode/skills/create-plans/templates/summary.md
</execution_context>

<context>
@.planning/BRIEF.md
@.planning/ROADMAP.md
@AUTHENTICATION_DOCUMENTATION.md
@frontend/src/stores/useAuthStore.ts
@frontend/src/App.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ProtectedRoute.tsx component</name>
  <files>frontend/src/components/ProtectedRoute.tsx</files>
  <action>
Create `frontend/src/components/ProtectedRoute.tsx`:

```typescript
/**
 * ============================================================================
 * FILE: ProtectedRoute.tsx
 * LOCATION: frontend/src/components/ProtectedRoute.tsx
 * ============================================================================
 *
 * PURPOSE:
 *    Route guard component for protecting pages based on authentication
 *    and role requirements.
 *
 * ROLE IN PROJECT:
 *    Wraps protected routes in App.tsx to enforce authentication and
 *    role-based access control. Redirects to login if unauthenticated.
 *
 * KEY COMPONENTS:
 *    - ProtectedRoute: HOC for route protection
 *
 * DEPENDENCIES:
 *    - External: react, react-router-dom
 *    - Internal: useAuthStore, LoadingSpinner
 * ============================================================================
 */

import { ReactNode } from 'react';
import { Navigate, useLocation } from 'react-router-dom';
import { useAuthStore, UserRole } from '../stores/useAuthStore';
import { LoadingSpinner } from './LoadingSpinner';

interface ProtectedRouteProps {
    children: ReactNode;
    requiredRole?: UserRole | UserRole[];
    requiredDepartment?: string;
}

export function ProtectedRoute({
    children,
    requiredRole,
    requiredDepartment
}: ProtectedRouteProps) {
    const location = useLocation();
    const { user, isLoading, isInitialized } = useAuthStore();
    
    // Show loading spinner while auth is initializing
    if (!isInitialized || isLoading) {
        return <LoadingSpinner />;
    }
    
    // Redirect to login if not authenticated
    if (!user) {
        return (
            <Navigate 
                to="/login" 
                state={{ from: location.pathname }} 
                replace 
            />
        );
    }
    
    // Check role requirement
    if (requiredRole) {
        const roles = Array.isArray(requiredRole) ? requiredRole : [requiredRole];
        if (!roles.includes(user.role)) {
            // Redirect to home if role not allowed
            return <Navigate to="/" replace />;
        }
    }
    
    // Check department requirement (admins bypass this check)
    if (requiredDepartment && user.role !== 'admin') {
        if (user.departmentId !== requiredDepartment) {
            return <Navigate to="/" replace />;
        }
    }
    
    return <>{children}</>;
}

export { ProtectedRoute as default };
```

AVOID: Checking isAuthenticated() function instead of user object.
WHY: Direct user check is more reliable for null state.
  </action>
  <verify>cd frontend && npx tsc --noEmit src/components/ProtectedRoute.tsx 2>&1 | head -5</verify>
  <done>ProtectedRoute.tsx created and compiles without errors</done>
</task>

<task type="auto">
  <name>Task 2: Update App.tsx with auth initialization and routes</name>
  <files>frontend/src/App.tsx</files>
  <action>
Update `frontend/src/App.tsx` to:

1. Add imports:
   ```typescript
   import { useEffect } from 'react';
   import { BrowserRouter, Routes, Route } from 'react-router-dom';
   import { initAuthListener } from './stores/useAuthStore';
   import { ProtectedRoute } from './components/ProtectedRoute';
   import { LoginPage } from './pages/LoginPage';
   ```

2. Add auth initialization in App component:
   ```typescript
   function App() {
       useEffect(() => {
           const unsubscribe = initAuthListener();
           return () => unsubscribe();
       }, []);
       
       // ... rest of component
   }
   ```

3. Update Routes to include login and protected routes:
   ```typescript
   <Routes>
       {/* Public route */}
       <Route path="/login" element={<LoginPage />} />
       
       {/* Protected routes */}
       <Route path="/*" element={
           <ProtectedRoute>
               {/* Existing ExplorerPage or main content */}
               <ExplorerPage />
           </ProtectedRoute>
       } />
   </Routes>
   ```

Preserve existing imports and structure where possible. The exact implementation depends on current App.tsx structure.

AVOID: Removing QueryClientProvider or other existing providers.
WHY: Would break existing functionality.
  </action>
  <verify>cd frontend && npx tsc --noEmit src/App.tsx 2>&1 | head -5</verify>
  <done>App.tsx updated with auth initialization and protected routes</done>
</task>

<task type="auto">
  <name>Task 3: Add logout button to existing UI</name>
  <files>frontend/src/components/Sidebar.tsx</files>
  <action>
Find the Sidebar component (or header/nav component) and add a logout button:

1. Import auth store:
   ```typescript
   import { useAuthStore } from '../stores/useAuthStore';
   ```

2. Add user info and logout button at the bottom of sidebar:
   ```typescript
   function Sidebar() {
       const { user, logout } = useAuthStore();
       
       const handleLogout = () => {
           logout();
           // Navigation happens via ProtectedRoute redirect
       };
       
       return (
           <aside className="...existing classes...">
               {/* ... existing sidebar content ... */}
               
               {/* User info and logout at bottom */}
               {user && (
                   <div className="mt-auto p-4 border-t border-gray-200">
                       <div className="text-sm text-gray-600 mb-2">
                           <p className="font-medium">{user.displayName}</p>
                           <p className="text-xs text-gray-400">{user.role}</p>
                       </div>
                       <button
                           onClick={handleLogout}
                           className="w-full px-3 py-2 text-sm text-red-600 hover:bg-red-50 rounded-md transition-colors"
                       >
                           Sign out
                       </button>
                   </div>
               )}
           </aside>
       );
   }
   ```

If Sidebar.tsx doesn't exist, add logout to the appropriate navigation component.

AVOID: Putting logout in a place that's not easily accessible.
WHY: Users need easy access to sign out.
  </action>
  <verify>cd frontend && npm run build 2>&1 | tail -5</verify>
  <done>Logout button added to sidebar/navigation</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Login page, ProtectedRoute, and logout functionality</what-built>
  <how-to-verify>
    1. Start backend: `cd api && python -m uvicorn main:app --reload --port 8000`
    2. Start frontend: `cd frontend && npm run dev`
    3. Visit: http://localhost:5173
    4. Verify: Redirected to /login page
    5. Test: Login with admin@test.com / Admin123!
    6. Verify: Redirected to main page after login
    7. Test: Click logout button
    8. Verify: Redirected back to login page
    9. Test: Try accessing / directly (should redirect to login)
  </how-to-verify>
  <resume-signal>Type "approved" to continue, or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cd frontend && npm run build` succeeds
- [ ] LoginPage renders at /login
- [ ] Unauthenticated users redirected to /login
- [ ] Authenticated users can access protected routes
- [ ] Logout clears session and redirects to login
- [ ] Role-based route protection works (admin routes)
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors
- Full login/logout flow works
- Protected routes enforce authentication
</success_criteria>

<output>
After completion, create `.planning/phases/04-frontend-auth-ui/04-02-SUMMARY.md`
</output>
