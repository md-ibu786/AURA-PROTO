---
phase: 03-frontend-auth-state
plan: 03-02
type: execute
---

<objective>
Update the API client to include Bearer token in all authenticated requests.

Purpose: Ensure all API calls include authentication headers automatically.
Output: Updated `frontend/src/api/client.ts` with token injection.
</objective>

<execution_context>
@~/.Opencode/skills/create-plans/workflows/execute-phase.md
@~/.Opencode/skills/create-plans/templates/summary.md
</execution_context>

<context>
@.planning/BRIEF.md
@.planning/ROADMAP.md
@AUTHENTICATION_DOCUMENTATION.md
@frontend/src/api/client.ts
@frontend/src/stores/useAuthStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add getAuthHeaders helper function</name>
  <files>frontend/src/api/client.ts</files>
  <action>
Add a helper function to get auth headers at the top of client.ts (after imports):

```typescript
/**
 * Get authentication headers if token exists.
 * @returns Headers object with Authorization if token present.
 */
function getAuthHeaders(): HeadersInit {
    const token = localStorage.getItem('auth_token');
    if (token) {
        return { 'Authorization': `Bearer ${token}` };
    }
    return {};
}
```

AVOID: Importing useAuthStore directly.
WHY: Would create circular dependency issues; use localStorage directly.
  </action>
  <verify>cd frontend && npx tsc --noEmit src/api/client.ts 2>&1 | head -5</verify>
  <done>getAuthHeaders function added to client.ts</done>
</task>

<task type="auto">
  <name>Task 2: Update fetchApi to include auth headers</name>
  <files>frontend/src/api/client.ts</files>
  <action>
Update the fetchApi function to merge auth headers with request headers:

Find the fetchApi function and update the headers section:

```typescript
export async function fetchApi<T>(
    endpoint: string,
    options: RequestInit = {}
): Promise<T> {
    const url = `${API_BASE}${endpoint}`;
    
    // Merge auth headers with provided headers
    const headers: HeadersInit = {
        'Content-Type': 'application/json',
        ...getAuthHeaders(),
        ...options.headers,
    };
    
    const response = await fetch(url, {
        ...options,
        headers,
    });
    
    // ... rest of existing error handling
}
```

Ensure the existing error handling logic (DuplicateError, etc.) is preserved.

AVOID: Removing existing DuplicateError handling.
WHY: Other parts of the app depend on this error class.
  </action>
  <verify>cd frontend && npx tsc --noEmit src/api/client.ts 2>&1 | head -5</verify>
  <done>fetchApi includes auth headers</done>
</task>

<task type="auto">
  <name>Task 3: Update fetchFormData to include auth headers</name>
  <files>frontend/src/api/client.ts</files>
  <action>
Update the fetchFormData function to include auth headers:

Find the fetchFormData function and update headers:

```typescript
export async function fetchFormData<T>(
    endpoint: string,
    formData: FormData
): Promise<T> {
    const url = `${API_BASE}${endpoint}`;
    
    const response = await fetch(url, {
        method: 'POST',
        headers: {
            ...getAuthHeaders(),
            // Note: DO NOT set Content-Type for FormData
            // Browser sets it automatically with boundary
        },
        body: formData,
    });
    
    // ... rest of existing error handling
}
```

AVOID: Setting Content-Type header for FormData requests.
WHY: Browser must set it with proper multipart boundary.
  </action>
  <verify>cd frontend && npx tsc --noEmit src/api/client.ts 2>&1 | head -5</verify>
  <done>fetchFormData includes auth headers</done>
</task>

<task type="auto">
  <name>Task 4: Add 401 handling for token expiration</name>
  <files>frontend/src/api/client.ts</files>
  <action>
Update the error handling in fetchApi to handle 401 responses:

In the fetchApi function, add handling for 401 status:

```typescript
// After getting response, before other error handling:
if (response.status === 401) {
    // Clear invalid auth state
    localStorage.removeItem('auth_token');
    localStorage.removeItem('auth_user');
    
    // Redirect to login (optional, can also throw)
    if (typeof window !== 'undefined') {
        window.location.href = '/login';
    }
    
    throw new Error('Session expired. Please log in again.');
}
```

Place this BEFORE the existing error handling code.

AVOID: Using React Router navigation here.
WHY: client.ts is not a React component; use window.location.
  </action>
  <verify>cd frontend && npx tsc --noEmit src/api/client.ts 2>&1 | head -5</verify>
  <done>401 handling added to fetchApi</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cd frontend && npm run build` succeeds
- [ ] fetchApi includes Authorization header when token exists
- [ ] fetchFormData includes Authorization header when token exists
- [ ] 401 responses clear auth state and redirect to login
- [ ] No TypeScript errors
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- All API calls automatically include auth token
- Invalid tokens trigger logout and redirect
- No breaking changes to existing API functions
</success_criteria>

<output>
After completion, create `.planning/phases/03-frontend-auth-state/03-02-SUMMARY.md`
</output>
