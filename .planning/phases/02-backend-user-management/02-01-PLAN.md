---
phase: 02-backend-user-management
plan: 02-01
type: execute
---

<objective>
Create the user management API with CRUD operations for admin users.

Purpose: Enable admin users to manage all users in the system.
Output: `api/users.py` with complete user CRUD endpoints.
</objective>

<execution_context>
@~/.Opencode/skills/create-plans/workflows/execute-phase.md
@~/.Opencode/skills/create-plans/templates/summary.md
</execution_context>

<context>
@.planning/BRIEF.md
@.planning/ROADMAP.md
@AUTHENTICATION_DOCUMENTATION.md
@api/auth.py
@api/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create users.py with Pydantic models</name>
  <files>api/users.py</files>
  <action>
Create `api/users.py` with:

1. **Imports:**
   ```python
   from fastapi import APIRouter, HTTPException, Depends, status
   from pydantic import BaseModel, EmailStr
   from typing import Optional, List, Literal
   from datetime import datetime
   
   from auth import get_current_user, require_admin, UserInfo
   from config import get_db
   ```

2. **Request/Response models:**
   ```python
   class UserCreate(BaseModel):
       email: EmailStr
       password: str
       display_name: str
       role: Literal["admin", "staff", "student"]
       department_id: Optional[str] = None
       subject_ids: Optional[List[str]] = None
   
   class UserUpdate(BaseModel):
       display_name: Optional[str] = None
       role: Optional[Literal["admin", "staff", "student"]] = None
       department_id: Optional[str] = None
       subject_ids: Optional[List[str]] = None
       status: Optional[Literal["active", "disabled"]] = None
   
   class UserResponse(BaseModel):
       id: str
       email: str
       display_name: Optional[str] = None
       role: str
       department_id: Optional[str] = None
       subject_ids: Optional[List[str]] = None
       status: str
       created_at: Optional[str] = None
       updated_at: Optional[str] = None
   ```

3. **Create router:**
   ```python
   router = APIRouter(prefix="/api", tags=["users"])
   ```

Include proper file header following AGENTS.md guidelines.

AVOID: Using `displayName` in Pydantic models (use snake_case).
WHY: Python convention; camelCase only in JSON responses.
  </action>
  <verify>python -c "from api.users import UserCreate, UserUpdate, UserResponse, router; print('Models imported')"</verify>
  <done>User models and router import without errors</done>
</task>

<task type="auto">
  <name>Task 2: Add GET /auth/me endpoint</name>
  <files>api/users.py</files>
  <action>
Add current user profile endpoint:

```python
@router.get("/auth/me")
async def get_me(user: UserInfo = Depends(get_current_user)):
    """Get current authenticated user profile."""
    db = get_db()
    user_doc = db.collection("users").document(user.uid).get()
    user_data = user_doc.to_dict() if user_doc.exists else {}
    
    return {
        "id": user.uid,
        "email": user.email,
        "displayName": user.display_name,
        "role": user.role,
        "departmentId": user.department_id,
        "status": user.status,
        "createdAt": user_data.get("createdAt"),
        "updatedAt": user_data.get("updatedAt")
    }
```

AVOID: Returning password field.
WHY: Security - never expose passwords in responses.
  </action>
  <verify>python -c "from api.users import router; paths = [r.path for r in router.routes]; print('/auth/me' in str(paths))"</verify>
  <done>/auth/me endpoint exists on router</done>
</task>

<task type="auto">
  <name>Task 3: Add list and create user endpoints</name>
  <files>api/users.py</files>
  <action>
Add user listing and creation endpoints:

1. **GET /users - List all users (admin only):**
   ```python
   @router.get("/users", response_model=List[UserResponse])
   async def list_users(
       role: Optional[str] = None,
       department_id: Optional[str] = None,
       admin: UserInfo = Depends(require_admin)
   ):
       """List all users. Admin only."""
       db = get_db()
       users_ref = db.collection("users")
       
       # Apply filters if provided
       if role:
           users_ref = users_ref.where("role", "==", role)
       if department_id:
           users_ref = users_ref.where("departmentId", "==", department_id)
       
       users = []
       for doc in users_ref.stream():
           data = doc.to_dict()
           users.append(UserResponse(
               id=doc.id,
               email=data.get("email", ""),
               display_name=data.get("displayName"),
               role=data.get("role", "student"),
               department_id=data.get("departmentId"),
               subject_ids=data.get("subjectIds"),
               status=data.get("status", "active"),
               created_at=data.get("createdAt"),
               updated_at=data.get("updatedAt")
           ))
       return users
   ```

2. **POST /users - Create user (admin only):**
   ```python
   @router.post("/users", response_model=UserResponse, status_code=status.HTTP_201_CREATED)
   async def create_user(
       user_data: UserCreate,
       admin: UserInfo = Depends(require_admin)
   ):
       """Create a new user. Admin only."""
       db = get_db()
       
       # Check if email already exists
       existing = list(db.collection("users").where("email", "==", user_data.email).stream())
       if existing:
           raise HTTPException(
               status_code=status.HTTP_409_CONFLICT,
               detail="Email already registered"
           )
       
       # Generate user ID and timestamps
       user_id = f"user-{int(datetime.now().timestamp() * 1000)}"
       now = datetime.utcnow().isoformat() + "Z"
       
       # Create user document
       new_user = {
           "email": user_data.email,
           "password": user_data.password,  # Plain text for mock auth
           "displayName": user_data.display_name,
           "role": user_data.role,
           "departmentId": user_data.department_id,
           "subjectIds": user_data.subject_ids,
           "status": "active",
           "createdAt": now,
           "updatedAt": now
       }
       
       db.collection("users").document(user_id).set(new_user)
       
       return UserResponse(
           id=user_id,
           email=new_user["email"],
           display_name=new_user["displayName"],
           role=new_user["role"],
           department_id=new_user["departmentId"],
           subject_ids=new_user["subjectIds"],
           status=new_user["status"],
           created_at=new_user["createdAt"],
           updated_at=new_user["updatedAt"]
       )
   ```

AVOID: Allowing duplicate emails.
WHY: Email is used for login - must be unique.
  </action>
  <verify>python -c "from api.users import router; paths = [r.path for r in router.routes]; print('/users' in str(paths))"</verify>
  <done>/users endpoints exist on router</done>
</task>

<task type="auto">
  <name>Task 4: Add update and delete user endpoints</name>
  <files>api/users.py</files>
  <action>
Add user update and deletion endpoints:

1. **GET /users/{user_id} - Get single user:**
   ```python
   @router.get("/users/{user_id}", response_model=UserResponse)
   async def get_user(
       user_id: str,
       current_user: UserInfo = Depends(get_current_user)
   ):
       """Get user by ID. Admin can get any user; others can only get themselves."""
       if current_user.role != "admin" and current_user.uid != user_id:
           raise HTTPException(
               status_code=status.HTTP_403_FORBIDDEN,
               detail="Access denied"
           )
       
       db = get_db()
       user_doc = db.collection("users").document(user_id).get()
       
       if not user_doc.exists:
           raise HTTPException(
               status_code=status.HTTP_404_NOT_FOUND,
               detail="User not found"
           )
       
       data = user_doc.to_dict()
       return UserResponse(
           id=user_doc.id,
           email=data.get("email", ""),
           display_name=data.get("displayName"),
           role=data.get("role", "student"),
           department_id=data.get("departmentId"),
           subject_ids=data.get("subjectIds"),
           status=data.get("status", "active"),
           created_at=data.get("createdAt"),
           updated_at=data.get("updatedAt")
       )
   ```

2. **PUT /users/{user_id} - Update user (admin only):**
   ```python
   @router.put("/users/{user_id}", response_model=UserResponse)
   async def update_user(
       user_id: str,
       update_data: UserUpdate,
       admin: UserInfo = Depends(require_admin)
   ):
       """Update a user. Admin only."""
       db = get_db()
       user_ref = db.collection("users").document(user_id)
       user_doc = user_ref.get()
       
       if not user_doc.exists:
           raise HTTPException(
               status_code=status.HTTP_404_NOT_FOUND,
               detail="User not found"
           )
       
       # Build update dict from non-None fields
       updates = {"updatedAt": datetime.utcnow().isoformat() + "Z"}
       if update_data.display_name is not None:
           updates["displayName"] = update_data.display_name
       if update_data.role is not None:
           updates["role"] = update_data.role
       if update_data.department_id is not None:
           updates["departmentId"] = update_data.department_id
       if update_data.subject_ids is not None:
           updates["subjectIds"] = update_data.subject_ids
       if update_data.status is not None:
           updates["status"] = update_data.status
       
       user_ref.update(updates)
       
       # Fetch updated document
       updated_doc = user_ref.get()
       data = updated_doc.to_dict()
       return UserResponse(
           id=updated_doc.id,
           email=data.get("email", ""),
           display_name=data.get("displayName"),
           role=data.get("role", "student"),
           department_id=data.get("departmentId"),
           subject_ids=data.get("subjectIds"),
           status=data.get("status", "active"),
           created_at=data.get("createdAt"),
           updated_at=data.get("updatedAt")
       )
   ```

3. **DELETE /users/{user_id} - Delete user (admin only):**
   ```python
   @router.delete("/users/{user_id}", status_code=status.HTTP_204_NO_CONTENT)
   async def delete_user(
       user_id: str,
       admin: UserInfo = Depends(require_admin)
   ):
       """Delete a user. Admin only."""
       # Prevent self-deletion
       if admin.uid == user_id:
           raise HTTPException(
               status_code=status.HTTP_400_BAD_REQUEST,
               detail="Cannot delete your own account"
           )
       
       db = get_db()
       user_ref = db.collection("users").document(user_id)
       user_doc = user_ref.get()
       
       if not user_doc.exists:
           raise HTTPException(
               status_code=status.HTTP_404_NOT_FOUND,
               detail="User not found"
           )
       
       user_ref.delete()
       return None
   ```

AVOID: Allowing admin to delete themselves.
WHY: Would lock out the only admin from the system.
  </action>
  <verify>python -c "from api.users import router; paths = [str(r.path) for r in router.routes]; print('{user_id}' in str(paths))"</verify>
  <done>/users/{user_id} endpoints exist on router</done>
</task>

<task type="auto">
  <name>Task 5: Mount users router in main.py</name>
  <files>api/main.py</files>
  <action>
Update `api/main.py` to include the users router:

1. Add import:
   ```python
   from users import router as users_router
   ```

2. Include router:
   ```python
   app.include_router(users_router)
   ```

AVOID: Duplicate router mounting.
WHY: Would create duplicate routes and errors.
  </action>
  <verify>python -c "from api.main import app; routes = [r.path for r in app.routes]; print('users' in str(routes) or '/api/users' in str(routes))"</verify>
  <done>Users router mounted in main.py</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `python -c "from api.users import router, UserCreate, UserUpdate, UserResponse"` succeeds
- [ ] GET /auth/me endpoint exists
- [ ] GET/POST /users endpoints exist (admin only)
- [ ] GET/PUT/DELETE /users/{user_id} endpoints exist
- [ ] Users router mounted in main.py
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Admin can list, create, update, delete users
- Non-admin users cannot access user management endpoints
- /auth/me returns current user profile
- Email uniqueness enforced on create
</success_criteria>

<output>
After completion, create `.planning/phases/02-backend-user-management/02-01-SUMMARY.md`
</output>
