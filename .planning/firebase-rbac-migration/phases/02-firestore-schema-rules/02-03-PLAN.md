---
phase: 02-firestore-schema-rules
type: execute
---

<objective>
Create comprehensive unit tests for Firestore Security Rules using the Firebase Emulator and @firebase/rules-unit-testing library.

Purpose: Security rules are critical - they must be thoroughly tested before production deployment. Unit tests verify that RBAC logic works correctly for all roles and edge cases, preventing security vulnerabilities.
Output: Complete test suite covering authentication, authorization, and data access scenarios for all user roles.
</objective>

<execution_context>
@~/.Opencode/skills/create-plans/workflows/execute-phase.md
@~/.Opencode/skills/create-plans/templates/summary.md
</execution_context>

<context>
@.planning/firebase-rbac-migration/BRIEF.md
@.planning/firebase-rbac-migration/ROADMAP.md
@FIREBASE_RBAC_MIGRATION_PLAN.md
@firestore.rules
@firebase.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Set up Firebase Emulator and testing dependencies</name>
  <files>package.json, firebase.json</files>
  <action>
    Install dependencies for Firestore security rules testing.
    
    First, check if there's already a package.json in the project root or e2e directory.
    
    Install Firebase CLI globally (if not already installed):
    ```bash
    npm install -g firebase-tools
    ```
    
    Install testing dependencies in the appropriate location (project root or e2e/):
    ```bash
    npm install --save-dev @firebase/rules-unit-testing firebase
    ```
    
    The @firebase/rules-unit-testing library provides:
    - `initializeTestEnvironment()` - Set up test environment
    - `assertSucceeds()` - Assert operation succeeds
    - `assertFails()` - Assert operation fails
    - Authentication context helpers
    
    Update firebase.json to include emulator configuration:
    ```json
    {
      "firestore": {
        "rules": "firestore.rules",
        "indexes": "firestore.indexes.json"
      },
      "emulators": {
        "firestore": {
          "port": 8080
        },
        "auth": {
          "port": 9099
        },
        "ui": {
          "enabled": true,
          "port": 4000
        }
      }
    }
    ```
    
    Note: If firebase.json was already created in 02-02, just verify the emulators section exists.
  </action>
  <verify>
    1. Check package.json has @firebase/rules-unit-testing in devDependencies
    2. Check firebase.json has emulators configuration
    3. Run: firebase --version (should show version number)
  </verify>
  <done>Firebase testing dependencies installed and emulators configured</done>
</task>

<task type="auto">
  <name>Task 2: Create test utilities and setup</name>
  <files>tests/firestore/rules-test-utils.js</files>
  <action>
    Create reusable test utilities for security rules testing.
    
    ```javascript
    /**
     * ============================================================================
     * FILE: rules-test-utils.js
     * LOCATION: tests/firestore/rules-test-utils.js
     * ============================================================================
     *
     * PURPOSE:
     *    Shared utilities for Firestore security rules tests
     *
     * ROLE IN PROJECT:
     *    Provides helper functions to create authenticated contexts,
     *    seed test data, and clean up between tests
     *
     * DEPENDENCIES:
     *    - @firebase/rules-unit-testing
     *    - firebase
     * ============================================================================
     */

    const { initializeTestEnvironment } = require('@firebase/rules-unit-testing');
    const fs = require('fs');
    const path = require('path');

    // Path to firestore.rules
    const RULES_FILE_PATH = path.join(__dirname, '..', '..', 'firestore.rules');

    let testEnv = null;

    /**
     * Initialize the test environment with firestore rules
     */
    async function initTestEnvironment() {
      if (!testEnv) {
        testEnv = await initializeTestEnvironment({
          projectId: 'demo-aura-notes-manager',
          firestore: {
            rules: fs.readFileSync(RULES_FILE_PATH, 'utf8'),
          },
        });
      }
      return testEnv;
    }

    /**
     * Clean up the test environment
     */
    async function cleanupTestEnvironment() {
      if (testEnv) {
        await testEnv.cleanup();
        testEnv = null;
      }
    }

    /**
     * Create an authenticated context for a user
     * @param {string} uid - User ID
     * @param {Object} token - Custom claims (role, etc.)
     * @returns {Object} Authenticated context with firestore()
     */
    function createAuthContext(uid, token = {}) {
      return testEnv.authenticatedContext(uid, token);
    }

    /**
     * Create an unauthenticated context
     * @returns {Object} Unauthenticated context with firestore()
     */
    function createUnauthContext() {
      return testEnv.unauthenticatedContext();
    }

    /**
     * Create test user data
     * @param {Object} overrides - Override default values
     */
    function createUserData(overrides = {}) {
      return {
        uid: 'test-user-123',
        email: 'test@aura.edu',
        displayName: 'Test User',
        role: 'student',
        status: 'active',
        departmentId: 'dept-cs',
        subjectIds: [],
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        ...overrides,
      };
    }

    /**
     * Create test note data
     * @param {Object} overrides - Override default values
     */
    function createNoteData(overrides = {}) {
      return {
        title: 'Test Note',
        content: 'Test content',
        subjectId: 'sub-math-101',
        departmentId: 'dept-math',
        createdBy: 'test-user-123',
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        ...overrides,
      };
    }

    /**
     * Seed test data into Firestore
     * @param {Object} db - Firestore instance
     * @param {string} collection - Collection name
     * @param {string} docId - Document ID
     * @param {Object} data - Document data
     */
    async function seedDocument(db, collection, docId, data) {
      await db.collection(collection).doc(docId).set(data);
    }

    module.exports = {
      initTestEnvironment,
      cleanupTestEnvironment,
      createAuthContext,
      createUnauthContext,
      createUserData,
      createNoteData,
      seedDocument,
    };
    ```
  </action>
  <verify>
    1. Check tests/firestore/rules-test-utils.js exists
    2. Verify all helper functions are exported
    3. Check that firestore.rules path is correct
  </verify>
  <done>Test utilities created with helper functions for auth contexts and data seeding</done>
</task>

<task type="auto">
  <name>Task 3: Create authentication tests</name>
  <files>tests/firestore/auth.test.js</files>
  <action>
    Create tests for basic authentication requirements.
    
    ```javascript
    /**
     * ============================================================================
     * FILE: auth.test.js
     * LOCATION: tests/firestore/auth.test.js
     * ============================================================================
     *
     * PURPOSE:
     *    Test authentication requirements for Firestore access
     *
     * ROLE IN PROJECT:
     *    Verifies that unauthenticated users cannot access any data
     * ============================================================================
     */

    const { assertFails, assertSucceeds } = require('@firebase/rules-unit-testing');
    const {
      initTestEnvironment,
      cleanupTestEnvironment,
      createAuthContext,
      createUnauthContext,
      createUserData,
      seedDocument,
    } = require('./rules-test-utils');

    describe('Authentication', () => {
      beforeAll(async () => {
        await initTestEnvironment();
      });

      afterAll(async () => {
        await cleanupTestEnvironment();
      });

      afterEach(async () => {
        // Clear data between tests
        const env = await initTestEnvironment();
        await env.clearFirestore();
      });

      test('unauthenticated users cannot read users collection', async () => {
        const unauth = createUnauthContext();
        const db = unauth.firestore();

        await assertFails(db.collection('users').get());
      });

      test('unauthenticated users cannot read departments', async () => {
        const unauth = createUnauthContext();
        const db = unauth.firestore();

        await assertFails(db.collection('departments').get());
      });

      test('unauthenticated users cannot read notes', async () => {
        const unauth = createUnauthContext();
        const db = unauth.firestore();

        await assertFails(db.collection('notes').get());
      });

      test('authenticated users can read departments', async () => {
        const auth = createAuthContext('user-123', { role: 'student' });
        const db = auth.firestore();

        await assertSucceeds(db.collection('departments').get());
      });

      test('authenticated users can read subjects', async () => {
        const auth = createAuthContext('user-123', { role: 'student' });
        const db = auth.firestore();

        await assertSucceeds(db.collection('subjects').get());
      });
    });
    ```
  </action>
  <verify>
    1. Check tests/firestore/auth.test.js exists
    2. Verify tests cover unauthenticated denial
    3. Verify tests cover authenticated access
  </verify>
  <done>Authentication tests created covering unauthenticated and authenticated access</done>
</task>

<task type="auto">
  <name>Task 4: Create admin role tests</name>
  <files>tests/firestore/admin.test.js</files>
  <action>
    Create comprehensive tests for admin role permissions.
    
    ```javascript
    /**
     * ============================================================================
     * FILE: admin.test.js
     * LOCATION: tests/firestore/admin.test.js
     * ============================================================================
     *
     * PURPOSE:
     *    Test admin role permissions across all collections
     * ============================================================================
     */

    const { assertFails, assertSucceeds } = require('@firebase/rules-unit-testing');
    const {
      initTestEnvironment,
      cleanupTestEnvironment,
      createAuthContext,
      createUserData,
      createNoteData,
      seedDocument,
    } = require('./rules-test-utils');

    describe('Admin Role', () => {
      let adminContext;
      let adminDb;

      beforeAll(async () => {
        await initTestEnvironment();
        adminContext = createAuthContext('admin-123', { role: 'admin' });
        adminDb = adminContext.firestore();
      });

      afterAll(async () => {
        await cleanupTestEnvironment();
      });

      afterEach(async () => {
        const env = await initTestEnvironment();
        await env.clearFirestore();
      });

      describe('Users Collection', () => {
        test('admin can list all users', async () => {
          await assertSucceeds(adminDb.collection('users').get());
        });

        test('admin can create users', async () => {
          const userData = createUserData({
            uid: 'new-user-456',
            email: 'new@aura.edu',
            role: 'staff',
          });

          await assertSucceeds(
            adminDb.collection('users').doc('new-user-456').set(userData)
          );
        });

        test('admin can update any user', async () => {
          // Seed a user
          await seedDocument(adminDb, 'users', 'user-456', createUserData({
            uid: 'user-456',
            status: 'active',
          }));

          // Admin updates the user
          await assertSucceeds(
            adminDb.collection('users').doc('user-456').update({ status: 'disabled' })
          );
        });

        test('admin can delete users', async () => {
          await seedDocument(adminDb, 'users', 'user-456', createUserData({
            uid: 'user-456',
          }));

          await assertSucceeds(
            adminDb.collection('users').doc('user-456').delete()
          );
        });
      });

      describe('Notes Collection', () => {
        test('admin can read all notes', async () => {
          await assertSucceeds(adminDb.collection('notes').get());
        });

        test('admin can create notes in any department', async () => {
          const noteData = createNoteData({
            departmentId: 'dept-math',
            subjectId: 'sub-math-101',
          });

          await assertSucceeds(
            adminDb.collection('notes').doc('note-1').set(noteData)
          );
        });

        test('admin can update any note', async () => {
          await seedDocument(adminDb, 'notes', 'note-1', createNoteData());

          await assertSucceeds(
            adminDb.collection('notes').doc('note-1').update({ title: 'Updated' })
          );
        });

        test('admin can delete any note', async () => {
          await seedDocument(adminDb, 'notes', 'note-1', createNoteData());

          await assertSucceeds(
            adminDb.collection('notes').doc('note-1').delete()
          );
        });
      });

      describe('Departments Collection', () => {
        test('admin can CRUD departments', async () => {
          await assertSucceeds(
            adminDb.collection('departments').doc('dept-new').set({
              name: 'New Department',
              code: 'NEW',
            })
          );

          await assertSucceeds(
            adminDb.collection('departments').doc('dept-new').update({ name: 'Updated' })
          );

          await assertSucceeds(
            adminDb.collection('departments').doc('dept-new').delete()
          );
        });
      });
    });
    ```
  </action>
  <verify>
    1. Check tests/firestore/admin.test.js exists
    2. Verify tests cover users, notes, and departments
    3. Verify tests cover CRUD operations
  </verify>
  <done>Admin role tests created covering all collections and CRUD operations</done>
</task>

<task type="auto">
  <name>Task 5: Create staff role tests</name>
  <files>tests/firestore/staff.test.js</files>
  <action>
    Create tests for staff role with subject-based permissions.
    
    ```javascript
    /**
     * ============================================================================
     * FILE: staff.test.js
     * LOCATION: tests/firestore/staff.test.js
     * ============================================================================
     *
     * PURPOSE:
     *    Test staff role permissions with subject access control
     * ============================================================================
     */

    const { assertFails, assertSucceeds } = require('@firebase/rules-unit-testing');
    const {
      initTestEnvironment,
      cleanupTestEnvironment,
      createAuthContext,
      createUserData,
      createNoteData,
      seedDocument,
    } = require('./rules-test-utils');

    describe('Staff Role', () => {
      let staffUid = 'staff-123';
      let staffSubjectId = 'sub-math-101';
      let otherSubjectId = 'sub-physics-101';
      let staffDeptId = 'dept-math';

      let staffContext;
      let staffDb;
      let adminContext;
      let adminDb;

      beforeAll(async () => {
        await initTestEnvironment();
        
        // Create admin context for seeding data
        adminContext = createAuthContext('admin-123', { role: 'admin' });
        adminDb = adminContext.firestore();
      });

      beforeEach(async () => {
        const env = await initTestEnvironment();
        await env.clearFirestore();

        // Create staff user document with assigned subjects
        await seedDocument(adminDb, 'users', staffUid, createUserData({
          uid: staffUid,
          role: 'staff',
          subjectIds: [staffSubjectId],
          departmentId: staffDeptId,
        }));

        // Create staff context with Custom Claims
        staffContext = createAuthContext(staffUid, { role: 'staff' });
        staffDb = staffContext.firestore();
      });

      afterAll(async () => {
        await cleanupTestEnvironment();
      });

      describe('User Management', () => {
        test('staff can read their own user document', async () => {
          await assertSucceeds(staffDb.collection('users').doc(staffUid).get());
        });

        test('staff cannot list all users', async () => {
          await assertFails(staffDb.collection('users').get());
        });

        test('staff cannot create users', async () => {
          await assertFails(
            staffDb.collection('users').doc('new-user').set(createUserData())
          );
        });

        test('staff cannot update other users', async () => {
          // Create another user
          await seedDocument(adminDb, 'users', 'other-user', createUserData({
            uid: 'other-user',
          }));

          await assertFails(
            staffDb.collection('users').doc('other-user').update({ status: 'disabled' })
          );
        });
      });

      describe('Notes - Assigned Subjects', () => {
        test('staff can read notes in assigned subjects', async () => {
          await seedDocument(adminDb, 'notes', 'note-1', createNoteData({
            subjectId: staffSubjectId,
            departmentId: staffDeptId,
          }));

          await assertSucceeds(staffDb.collection('notes').doc('note-1').get());
        });

        test('staff can create notes in assigned subjects', async () => {
          const noteData = createNoteData({
            subjectId: staffSubjectId,
            departmentId: staffDeptId,
          });

          await assertSucceeds(
            staffDb.collection('notes').doc('note-1').set(noteData)
          );
        });

        test('staff can update notes in assigned subjects', async () => {
          await seedDocument(adminDb, 'notes', 'note-1', createNoteData({
            subjectId: staffSubjectId,
            departmentId: staffDeptId,
          }));

          await assertSucceeds(
            staffDb.collection('notes').doc('note-1').update({ title: 'Updated' })
          );
        });
      });

      describe('Notes - Other Subjects', () => {
        test('staff cannot read notes in unassigned subjects', async () => {
          await seedDocument(adminDb, 'notes', 'note-2', createNoteData({
            subjectId: otherSubjectId,
            departmentId: 'dept-physics',
          }));

          await assertFails(staffDb.collection('notes').doc('note-2').get());
        });

        test('staff cannot create notes in unassigned subjects', async () => {
          const noteData = createNoteData({
            subjectId: otherSubjectId,
            departmentId: 'dept-physics',
          });

          await assertFails(
            staffDb.collection('notes').doc('note-2').set(noteData)
          );
        });
      });

      describe('Departments', () => {
        test('staff can read departments', async () => {
          await assertSucceeds(staffDb.collection('departments').get());
        });

        test('staff cannot modify departments', async () => {
          await assertFails(
            staffDb.collection('departments').doc('dept-new').set({ name: 'New' })
          );
        });
      });
    });
    ```
  </action>
  <verify>
    1. Check tests/firestore/staff.test.js exists
    2. Verify tests cover subject-based access control
    3. Verify tests distinguish between assigned and unassigned subjects
  </verify>
  <done>Staff role tests created with subject-based permission testing</done>
</task>

<task type="auto">
  <name>Task 6: Create student role tests and edge cases</name>
  <files>tests/firestore/student.test.js</files>
  <action>
    Create tests for student role (read-only, department-limited) and edge cases.
    
    ```javascript
    /**
     * ============================================================================
     * FILE: student.test.js
     * LOCATION: tests/firestore/student.test.js
     * ============================================================================
     *
     * PURPOSE:
     *    Test student role permissions (read-only, department-based)
     *    and edge cases
     * ============================================================================
     */

    const { assertFails, assertSucceeds } = require('@firebase/rules-unit-testing');
    const {
      initTestEnvironment,
      cleanupTestEnvironment,
      createAuthContext,
      createUserData,
      createNoteData,
      seedDocument,
    } = require('./rules-test-utils');

    describe('Student Role', () => {
      let studentUid = 'student-123';
      let studentDeptId = 'dept-cs';
      let otherDeptId = 'dept-math';

      let studentContext;
      let studentDb;
      let adminContext;
      let adminDb;

      beforeAll(async () => {
        await initTestEnvironment();
        
        adminContext = createAuthContext('admin-123', { role: 'admin' });
        adminDb = adminContext.firestore();
      });

      beforeEach(async () => {
        const env = await initTestEnvironment();
        await env.clearFirestore();

        // Create student user document
        await seedDocument(adminDb, 'users', studentUid, createUserData({
          uid: studentUid,
          role: 'student',
          departmentId: studentDeptId,
          subjectIds: [],
        }));

        studentContext = createAuthContext(studentUid, { role: 'student' });
        studentDb = studentContext.firestore();
      });

      afterAll(async () => {
        await cleanupTestEnvironment();
      });

      describe('Read Access', () => {
        test('student can read notes in their department', async () => {
          await seedDocument(adminDb, 'notes', 'note-1', createNoteData({
            departmentId: studentDeptId,
            subjectId: 'sub-cs-101',
          }));

          await assertSucceeds(studentDb.collection('notes').doc('note-1').get());
        });

        test('student can read departments', async () => {
          await assertSucceeds(studentDb.collection('departments').get());
        });

        test('student can read subjects', async () => {
          await assertSucceeds(studentDb.collection('subjects').get());
        });
      });

      describe('Cross-Department Access Denied', () => {
        test('student cannot read notes from other departments', async () => {
          await seedDocument(adminDb, 'notes', 'note-2', createNoteData({
            departmentId: otherDeptId,
            subjectId: 'sub-math-101',
          }));

          await assertFails(studentDb.collection('notes').doc('note-2').get());
        });
      });

      describe('Write Access Denied', () => {
        test('student cannot create notes', async () => {
          await assertFails(
            studentDb.collection('notes').doc('note-new').set(createNoteData())
          );
        });

        test('student cannot update notes', async () => {
          await seedDocument(adminDb, 'notes', 'note-1', createNoteData({
            departmentId: studentDeptId,
          }));

          await assertFails(
            studentDb.collection('notes').doc('note-1').update({ title: 'Hacked' })
          );
        });

        test('student cannot delete notes', async () => {
          await seedDocument(adminDb, 'notes', 'note-1', createNoteData({
            departmentId: studentDeptId,
          }));

          await assertFails(studentDb.collection('notes').doc('note-1').delete());
        });

        test('student cannot modify departments', async () => {
          await assertFails(
            studentDb.collection('departments').doc('dept-cs').update({ name: 'Hacked' })
          );
        });
      });
    });

    describe('Edge Cases', () => {
      let adminContext;
      let adminDb;

      beforeAll(async () => {
        await initTestEnvironment();
        adminContext = createAuthContext('admin-123', { role: 'admin' });
        adminDb = adminContext.firestore();
      });

      beforeEach(async () => {
        const env = await initTestEnvironment();
        await env.clearFirestore();
      });

      afterAll(async () => {
        await cleanupTestEnvironment();
      });

      test('disabled user cannot access data', async () => {
        // Create disabled user
        await seedDocument(adminDb, 'users', 'disabled-user', createUserData({
          uid: 'disabled-user',
          role: 'student',
          status: 'disabled',
        }));

        const disabledContext = createAuthContext('disabled-user', { role: 'student' });
        const disabledDb = disabledContext.firestore();

        await assertFails(disabledDb.collection('departments').get());
      });

      test('user without role claim cannot access admin data', async () => {
        const noRoleContext = createAuthContext('user-no-role', {});
        const noRoleDb = noRoleContext.firestore();

        await assertFails(noRoleDb.collection('users').get());
      });
    });
    ```
  </action>
  <verify>
    1. Check tests/firestore/student.test.js exists
    2. Verify tests cover department-based access
    3. Verify tests cover read-only permissions
    4. Verify edge cases (disabled user, missing role)
  </verify>
  <done>Student role tests and edge case tests created</done>
</task>

<task type="auto">
  <name>Task 7: Create test runner script and CI configuration</name>
  <files>package.json, .github/workflows/firestore-rules.yml</files>
  <action>
    Create a test runner script and GitHub Actions workflow for automated testing.
    
    Update package.json scripts:
    ```json
    {
      "scripts": {
        "test:rules": "firebase emulators:exec --only firestore 'jest tests/firestore/'",
        "test:rules:watch": "firebase emulators:exec --only firestore 'jest tests/firestore/ --watch'",
        "emulators:start": "firebase emulators:start --only firestore,auth"
      }
    }
    ```

    Create Jest configuration (jest.config.js):
    ```javascript
    module.exports = {
      testEnvironment: 'node',
      testMatch: ['**/tests/firestore/**/*.test.js'],
      setupFilesAfterEnv: ['./tests/firestore/setup.js'],
      testTimeout: 30000, // Firestore emulator can be slow
    };
    ```

    Create test setup file (tests/firestore/setup.js):
    ```javascript
    // Increase timeout for Firestore emulator operations
    jest.setTimeout(30000);
    ```

    Create GitHub Actions workflow (.github/workflows/firestore-rules.yml):
    ```yaml
    name: Firestore Security Rules Tests

    on:
      push:
        branches: [main]
      pull_request:
        branches: [main]

    jobs:
      test:
        runs-on: ubuntu-latest
        
        steps:
        - uses: actions/checkout@v3
        
        - name: Setup Node.js
          uses: actions/setup-node@v3
          with:
            node-version: '18'
            cache: 'npm'
        
        - name: Install dependencies
          run: npm ci
        
        - name: Install Firebase CLI
          run: npm install -g firebase-tools
        
        - name: Run Firestore rules tests
          run: npm run test:rules
    ```
  </action>
  <verify>
    1. Check package.json has test:rules script
    2. Check jest.config.js exists
    3. Check .github/workflows/firestore-rules.yml exists
  </verify>
  <done>Test runner scripts and CI workflow created</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] @firebase/rules-unit-testing installed
- [ ] firebase.json has emulator configuration
- [ ] tests/firestore/rules-test-utils.js created with helpers
- [ ] tests/firestore/auth.test.js tests authentication
- [ ] tests/firestore/admin.test.js tests admin CRUD
- [ ] tests/firestore/staff.test.js tests subject-based access
- [ ] tests/firestore/student.test.js tests read-only department access
- [ ] All test files have proper Jest structure (describe, test)
- [ ] package.json has test:rules script
- [ ] GitHub Actions workflow created
- [ ] npm run test:rules executes without errors (run to verify)
</verification>

<success_criteria>
- All tasks completed
- Complete test suite covering all roles and edge cases
- Tests verify both success and failure cases
- CI/CD pipeline configured
- Test utilities are reusable
- Security rules pass all tests
- Ready for deployment with confidence
</success_criteria>

<output>
After completion, create `.planning/firebase-rbac-migration/phases/02-firestore-schema-rules/02-03-SUMMARY.md`
</output>
