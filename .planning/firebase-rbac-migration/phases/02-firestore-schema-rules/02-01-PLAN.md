---
phase: 02-firestore-schema-rules
type: execute
---

<objective>
Define the production Firestore user collection schema with RBAC fields for the hybrid authentication model.

Purpose: Establish the data structure that will store user roles, department assignments, and subject permissions. This schema enables the hybrid RBAC approach: Custom Claims for global roles, Firestore Documents for granular permissions.
Output: Documented schema specification and TypeScript/Python interfaces for type safety.
</objective>

<execution_context>
@~/.Opencode/skills/create-plans/workflows/execute-phase.md
@~/.Opencode/skills/create-plans/templates/summary.md
</execution_context>

<context>
@.planning/firebase-rbac-migration/BRIEF.md
@.planning/firebase-rbac-migration/ROADMAP.md
@FIREBASE_RBAC_MIGRATION_PLAN.md
@api/auth.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create schema documentation</name>
  <files>documentations/firebase-schema.md</files>
  <action>
    Create comprehensive schema documentation at documentations/firebase-schema.md.
    
    Document the `users` collection structure:
    
    ```markdown
    # Firebase Firestore Schema
    
    ## Collection: users
    
    Document ID: `{uid}` (matches Firebase Auth UID)
    
    ### Schema Definition
    
    | Field | Type | Required | Description |
    |-------|------|----------|-------------|
    | uid | string | Yes | Primary key, matches Firebase Auth UID |
    | email | string | Yes | User's email address |
    | displayName | string | No | User's display name |
    | role | string | Yes | Enum: 'admin', 'staff', 'student' |
    | status | string | Yes | Enum: 'active', 'disabled' |
    | departmentId | string | Conditional | Required for 'student' role. References departments/{id} |
    | subjectIds | array<string> | Conditional | Required for 'staff' role. Array of subject references |
    | createdAt | timestamp | Yes | Document creation time |
    | updatedAt | timestamp | Yes | Last update time |
    
    ### Field Constraints
    
    - role must be one of: 'admin', 'staff', 'student'
    - status must be one of: 'active', 'disabled'
    - departmentId required when role == 'student'
    - subjectIds required when role == 'staff'
    - subjectIds should be empty when role == 'admin' or 'student'
    
    ### Example Documents
    
    #### Admin User
    ```json
    {
      "uid": "abc123",
      "email": "admin@aura.edu",
      "displayName": "System Administrator",
      "role": "admin",
      "status": "active",
      "departmentId": null,
      "subjectIds": [],
      "createdAt": "2026-02-04T10:00:00Z",
      "updatedAt": "2026-02-04T10:00:00Z"
    }
    ```
    
    #### Staff User
    ```json
    {
      "uid": "def456",
      "email": "staff@aura.edu",
      "displayName": "Math Teacher",
      "role": "staff",
      "status": "active",
      "departmentId": "dept-math",
      "subjectIds": ["sub-calc-1", "sub-algebra"],
      "createdAt": "2026-02-04T10:00:00Z",
      "updatedAt": "2026-02-04T10:00:00Z"
    }
    ```
    
    #### Student User
    ```json
    {
      "uid": "ghi789",
      "email": "student@aura.edu",
      "displayName": "John Doe",
      "role": "student",
      "status": "active",
      "departmentId": "dept-cs",
      "subjectIds": [],
      "createdAt": "2026-02-04T10:00:00Z",
      "updatedAt": "2026-02-04T10:00:00Z"
    }
    ```
    ```
    
    Include sections for:
    - Schema versioning (add _v: 1 field for future migrations)
    - Index recommendations
    - Security considerations
  </action>
  <verify>
    Read documentations/firebase-schema.md and verify it contains:
    - Complete field definitions with types
    - Required vs optional fields
    - Field constraints and validation rules
    - Example documents for each role
    - Index recommendations
  </verify>
  <done>Schema documentation created with complete field definitions and examples</done>
</task>

<task type="auto">
  <name>Task 2: Update TypeScript types for Firestore user</name>
  <files>frontend/src/types/user.ts (or create if doesn't exist)</files>
  <action>
    Create or update TypeScript types to match the Firestore schema.
    
    Find where user types are currently defined. Common locations:
    - frontend/src/types/index.ts
    - frontend/src/types/user.ts
    - frontend/src/stores/useAuthStore.ts
    
    Create a dedicated type file if none exists:
    
    ```typescript
    /**
     * ============================================================================
     * FILE: user.ts
     * LOCATION: frontend/src/types/user.ts
     * ============================================================================
     *
     * PURPOSE:
     *    TypeScript type definitions for Firestore user documents
     *
     * ROLE IN PROJECT:
     *    Defines the shape of user data stored in Firestore users collection
     *    Used by auth store, API client, and UI components
     *
     * DEPENDENCIES:
     *    - None (pure type definitions)
     * ============================================================================
     */

    export type UserRole = 'admin' | 'staff' | 'student';
    export type UserStatus = 'active' | 'disabled';

    export interface FirestoreUser {
      uid: string;
      email: string;
      displayName?: string;
      role: UserRole;
      status: UserStatus;
      departmentId: string | null;
      subjectIds: string[];
      createdAt: string; // ISO timestamp
      updatedAt: string; // ISO timestamp
    }

    // For creating new users (omit generated fields)
    export interface CreateUserInput {
      email: string;
      displayName?: string;
      role: UserRole;
      status?: UserStatus;
      departmentId?: string;
      subjectIds?: string[];
    }

    // For updating users (all fields optional)
    export interface UpdateUserInput {
      email?: string;
      displayName?: string;
      role?: UserRole;
      status?: UserStatus;
      departmentId?: string;
      subjectIds?: string[];
    }
    ```
    
    Update any existing AuthUser interface to use these types or extend them.
    Ensure backward compatibility with existing code.
  </action>
  <verify>
    1. Check that frontend/src/types/user.ts exists (or wherever types are defined)
    2. Verify FirestoreUser interface has all required fields
    3. Verify CreateUserInput and UpdateUserInput are defined
    4. Check that existing code can import and use these types
  </verify>
  <done>TypeScript types created for FirestoreUser, CreateUserInput, and UpdateUserInput</done>
</task>

<task type="auto">
  <name>Task 3: Update Python Pydantic models</name>
  <files>api/auth.py, api/models.py (or create models.py)</files>
  <action>
    Update or create Pydantic models to match the Firestore schema.
    
    Check if models already exist in api/auth.py or if there's a separate api/models.py.
    
    If api/auth.py has the UserInfo model, update it to match:
    
    ```python
    from typing import Literal, Optional
    from pydantic import BaseModel, Field
    from datetime import datetime

    class FirestoreUser(BaseModel):
        """Represents a user document in Firestore."""
        uid: str = Field(..., description="Firebase Auth UID")
        email: str = Field(..., description="User email address")
        displayName: Optional[str] = Field(None, description="User display name")
        role: Literal['admin', 'staff', 'student'] = Field(..., description="User role")
        status: Literal['active', 'disabled'] = Field('active', description="Account status")
        departmentId: Optional[str] = Field(None, description="Department ID (required for students)")
        subjectIds: list[str] = Field(default_factory=list, description="Assigned subject IDs (required for staff)")
        createdAt: datetime = Field(default_factory=datetime.utcnow, description="Document creation time")
        updatedAt: datetime = Field(default_factory=datetime.utcnow, description="Last update time")
        
        class Config:
            json_encoders = {
                datetime: lambda v: v.isoformat()
            }
    
    class CreateUserInput(BaseModel):
        """Input for creating a new user."""
        email: str
        displayName: Optional[str] = None
        role: Literal['admin', 'staff', 'student']
        status: Literal['active', 'disabled'] = 'active'
        departmentId: Optional[str] = None
        subjectIds: list[str] = Field(default_factory=list)
        
        @validator('departmentId')
        def validate_department(cls, v, values):
            if values.get('role') == 'student' and not v:
                raise ValueError('departmentId is required for student role')
            return v
        
        @validator('subjectIds')
        def validate_subjects(cls, v, values):
            if values.get('role') == 'staff' and not v:
                raise ValueError('subjectIds is required for staff role')
            return v
    
    class UpdateUserInput(BaseModel):
        """Input for updating an existing user."""
        email: Optional[str] = None
        displayName: Optional[str] = None
        role: Optional[Literal['admin', 'staff', 'student']] = None
        status: Optional[Literal['active', 'disabled']] = None
        departmentId: Optional[str] = None
        subjectIds: Optional[list[str]] = None
    ```
    
    Add validators to enforce constraints:
    - departmentId required for student role
    - subjectIds required for staff role
    
    If models are in a separate file, update imports in auth.py.
  </action>
  <verify>
    1. Read api/auth.py to check Pydantic models
    2. Verify FirestoreUser, CreateUserInput, UpdateUserInput exist
    3. Verify validators enforce role-based constraints
    4. Test: python -c "from api.auth import FirestoreUser; print('OK')"
  </verify>
  <done>Pydantic models updated with FirestoreUser schema and validation</done>
</task>

<task type="auto">
  <name>Task 4: Create validation utilities</name>
  <files>api/utils/validators.py (or api/validators.py)</files>
  <action>
    Create utility functions for validating user data against the schema.
    
    ```python
    """
    ============================================================================
    FILE: validators.py
    LOCATION: api/utils/validators.py
    ============================================================================

    PURPOSE:
        Validation utilities for user data and RBAC constraints

    ROLE IN PROJECT:
        Shared validation logic used by user creation and update endpoints
        Ensures data integrity across the application

    DEPENDENCIES:
        - None (pure validation functions)
    ============================================================================
    """

    from typing import Literal

    def validate_user_role_constraints(
        role: Literal['admin', 'staff', 'student'],
        department_id: str | None,
        subject_ids: list[str]
    ) -> None:
        """
        Validate that user data matches role requirements.
        
        Raises:
            ValueError: If validation fails
        """
        if role == 'student':
            if not department_id:
                raise ValueError("departmentId is required for student role")
            if subject_ids:
                raise ValueError("subjectIds should be empty for student role")
        
        elif role == 'staff':
            if not subject_ids:
                raise ValueError("subjectIds is required for staff role")
            # departmentId is optional but recommended for staff
        
        elif role == 'admin':
            # Admins can access everything, no specific constraints
            pass
        
        else:
            raise ValueError(f"Invalid role: {role}")

    def validate_status_transition(
        old_status: Literal['active', 'disabled'],
        new_status: Literal['active', 'disabled'],
        current_user_role: Literal['admin', 'staff', 'student']
    ) -> None:
        """
        Validate if a status change is allowed.
        
        Raises:
            ValueError: If transition is not allowed
        """
        if current_user_role != 'admin':
            raise ValueError("Only admins can change user status")
        
        if old_status == new_status:
            raise ValueError("New status must be different from current status")

    def normalize_user_data(data: dict) -> dict:
        """
        Normalize user data before saving to Firestore.
        
        - Sets default values for missing fields
        - Converts timestamps to Firestore format
        - Ensures consistent data types
        """
        normalized = data.copy()
        
        # Set defaults
        if 'status' not in normalized:
            normalized['status'] = 'active'
        
        if 'subjectIds' not in normalized:
            normalized['subjectIds'] = []
        
        if 'departmentId' not in normalized:
            normalized['departmentId'] = None
        
        # Ensure arrays are lists
        if isinstance(normalized.get('subjectIds'), tuple):
            normalized['subjectIds'] = list(normalized['subjectIds'])
        
        return normalized
    ```
    
    These utilities will be used when creating/updating users to ensure data consistency.
  </action>
  <verify>
    1. Create test to verify validators work:
       python -c "from api.utils.validators import validate_user_role_constraints; validate_user_role_constraints('student', 'dept-1', []); print('OK')"
    2. Test that invalid data raises ValueError
  </verify>
  <done>Validation utilities created for role constraints and data normalization</done>
</task>

<task type="auto">
  <name>Task 5: Update existing user endpoints to use new schema</name>
  <files>api/users.py</files>
  <action>
    Update existing user endpoints to use the new FirestoreUser schema.
    
    Current endpoints likely use the mock schema. Update them to:
    1. Accept CreateUserInput / UpdateUserInput in request bodies
    2. Validate role constraints using validator utilities
    3. Return FirestoreUser models in responses
    4. Handle timestamps properly
    
    Changes needed:
    - POST /api/users: Should create both Firebase Auth user AND Firestore document
    - PUT /api/users/{id}: Should update Firestore document
    - GET /api/users/{id}: Should return FirestoreUser model
    - GET /api/users: Should return list of FirestoreUser models
    
    Note: Full implementation with Firebase Auth integration happens in Phase 4.
    For now, just update the Pydantic models and validation to match the new schema.
    Keep the mock database logic in place - we'll swap it for real Firebase in Phase 4.
    
    Example of what to update:
    ```python
    @router.post("/api/users", response_model=FirestoreUser)
    async def create_user(
        input: CreateUserInput,
        current_user: UserInfo = Depends(require_admin)
    ):
        # Validate constraints
        validate_user_role_constraints(
            input.role,
            input.departmentId,
            input.subjectIds
        )
        
        # For now, create in mock DB (Phase 4 will add Firebase Auth)
        db = get_db()
        user_id = str(uuid.uuid4())
        user_data = {
            'uid': user_id,
            'email': input.email,
            'displayName': input.displayName,
            'role': input.role,
            'status': input.status,
            'departmentId': input.departmentId,
            'subjectIds': input.subjectIds,
            'createdAt': datetime.utcnow(),
            'updatedAt': datetime.utcnow()
        }
        db.collection('users').document(user_id).set(user_data)
        return FirestoreUser(**user_data)
    ```
  </action>
  <verify>
    1. Read api/users.py to see current implementation
    2. Verify endpoints use new Pydantic models
    3. Run existing tests to ensure they still pass
    4. Test manually: curl -X POST /api/users with sample data
  </verify>
  <done>User endpoints updated to use FirestoreUser schema and validation</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] documentations/firebase-schema.md exists with complete schema definition
- [ ] TypeScript types created in frontend/src/types/user.ts
- [ ] Pydantic models updated in api/auth.py (or api/models.py)
- [ ] Validation utilities created in api/utils/validators.py
- [ ] User endpoints (api/users.py) use new schema models
- [ ] `python -c "from api.auth import FirestoreUser"` succeeds
- [ ] All existing tests still pass
</verification>

<success_criteria>
- All tasks completed
- Schema documented with examples for all roles
- TypeScript and Python types match Firestore schema
- Validation utilities enforce role constraints
- User endpoints updated but still using mock database
- No breaking changes to existing functionality
- Ready for Phase 3 (Data Migration) and Phase 4 (Backend Auth Refactor)
</success_criteria>

<output>
After completion, create `.planning/firebase-rbac-migration/phases/02-firestore-schema-rules/02-01-SUMMARY.md`
</output>
