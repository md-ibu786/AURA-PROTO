---
phase: 02-firestore-schema-rules
type: execute
---

<objective>
Implement Firestore Security Rules with RBAC helper functions to enforce access control at the database level.

Purpose: Security rules are the last line of defense. Even if backend authorization is bypassed, these rules ensure users can only access data they're authorized for. This implements the hybrid RBAC model: Custom Claims for global roles, Firestore lookups for granular permissions.
Output: firestore.rules file with comprehensive RBAC logic and helper functions for all collections.
</objective>

<execution_context>
@~/.Opencode/skills/create-plans/workflows/execute-phase.md
@~/.Opencode/skills/create-plans/templates/summary.md
</execution_context>

<context>
@.planning/firebase-rbac-migration/BRIEF.md
@.planning/firebase-rbac-migration/ROADMAP.md
@FIREBASE_RBAC_MIGRATION_PLAN.md
@documentations/firebase-schema.md (from 02-01)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create firestore.rules with basic structure</name>
  <files>firestore.rules</files>
  <action>
    Create the firestore.rules file with the basic rules structure.
    
    Based on research, best practices for 2025:
    1. Use rules_version = '2' for latest features
    2. Deny by default at the root level
    3. Use helper functions for RBAC logic
    4. Combine Custom Claims (free, instant) with Firestore lookups (dynamic)
    
    Basic structure:
    ```javascript
    rules_version = '2';
    service cloud.firestore {
      match /databases/{database}/documents {
        
        // ========== HELPER FUNCTIONS ==========
        
        // Check if user is authenticated
        function isAuthenticated() {
          return request.auth != null;
        }
        
        // Get current user's UID
        function currentUserId() {
          return request.auth.uid;
        }
        
        // Check Custom Claims for global role
        function hasRole(role) {
          return request.auth.token.role == role;
        }
        
        // Check if user is admin (from Custom Claims)
        function isAdmin() {
          return hasRole('admin');
        }
        
        // Check if user is staff (from Custom Claims)
        function isStaff() {
          return hasRole('staff');
        }
        
        // Check if user is student (from Custom Claims)
        function isStudent() {
          return hasRole('student');
        }
        
        // Get user document from Firestore (for granular permissions)
        function getUser(userId) {
          return get(/databases/$(database)/documents/users/$(userId));
        }
        
        // Check if user is in a specific department (Firestore lookup)
        function isInDepartment(departmentId) {
          return getUser(currentUserId()).data.departmentId == departmentId;
        }
        
        // Check if user has access to a specific subject (Firestore lookup)
        function hasSubjectAccess(subjectId) {
          return subjectId in getUser(currentUserId()).data.subjectIds;
        }
        
        // Check if document is in user's department (for read operations)
        function isDocumentInMyDepartment() {
          return resource.data.departmentId == getUser(currentUserId()).data.departmentId;
        }
        
        // ========== DENY BY DEFAULT ==========
        
        // Deny all access by default
        match /{document=**} {
          allow read, write: if false;
        }
        
        // ========== USERS COLLECTION ==========
        
        match /users/{userId} {
          // Users can read their own document
          allow get: if isAuthenticated() && currentUserId() == userId;
          
          // Admins can read all users
          allow list: if isAdmin();
          
          // Only admins can create/update/delete users
          allow create, update, delete: if isAdmin();
        }
        
        // ... more collection rules will be added in next tasks
      }
    }
    ```
    
    Save this as firestore.rules in the project root.
  </action>
  <verify>
    1. Check firestore.rules exists
    2. Verify rules_version = '2' is at the top
    3. Verify helper functions are defined
    4. Verify deny-by-default is at root level
  </verify>
  <done>firestore.rules created with basic structure and helper functions</done>
</task>

<task type="auto">
  <name>Task 2: Add department/semester/subject rules</name>
  <files>firestore.rules</files>
  <action>
    Add rules for the hierarchy collections: departments, semesters, subjects.
    
    ```javascript
    // ========== DEPARTMENTS ==========
    
    match /departments/{departmentId} {
      // Anyone authenticated can read departments
      allow read: if isAuthenticated();
      
      // Only admins can modify departments
      allow create, update, delete: if isAdmin();
    }
    
    // ========== SEMESTERS ==========
    
    match /departments/{departmentId}/semesters/{semesterId} {
      // Anyone authenticated can read semesters
      allow read: if isAuthenticated();
      
      // Only admins can modify semesters
      allow create, update, delete: if isAdmin();
    }
    
    // Alternative if semesters is a root collection:
    match /semesters/{semesterId} {
      allow read: if isAuthenticated();
      allow create, update, delete: if isAdmin();
    }
    
    // ========== SUBJECTS ==========
    
    match /subjects/{subjectId} {
      // Anyone authenticated can read subjects
      allow read: if isAuthenticated();
      
      // Only admins can create/delete subjects
      allow create, delete: if isAdmin();
      
      // Admins can update any subject
      // Staff can update subjects they have access to
      allow update: if isAdmin() || 
        (isStaff() && hasSubjectAccess(subjectId));
    }
    ```
    
    Check the actual collection structure in mock_db.json or existing code to determine:
    - Are semesters nested under departments or root level?
    - Are subjects nested or root level?
    - What fields identify department/subject relationships?
    
    Update the rules to match the actual data structure.
  </action>
  <verify>
    1. Read firestore.rules to verify department/semester/subject rules
    2. Check that read access requires authentication
    3. Check that write access requires admin or specific role
  </verify>
  <done>Hierarchy collection rules added for departments, semesters, subjects</done>
</task>

<task type="auto">
  <name>Task 3: Add module and note rules</name>
  <files>firestore.rules</files>
  <action>
    Add rules for modules and notes collections with RBAC enforcement.
    
    These need more complex logic since:
    - Staff can edit notes in their assigned subjects
    - Students can only read notes in their department
    - Admins can do everything
    
    ```javascript
    // ========== MODULES ==========
    
    match /modules/{moduleId} {
      // Anyone authenticated can read modules
      allow read: if isAuthenticated();
      
      // Only admins can create/delete modules
      allow create, delete: if isAdmin();
      
      // Staff can update modules in subjects they have access to
      // Uses resource.data.subjectId to check the module's subject
      allow update: if isAdmin() || 
        (isStaff() && hasSubjectAccess(resource.data.subjectId));
    }
    
    // ========== NOTES ==========
    
    match /notes/{noteId} {
      // Students can only read notes in their department
      allow read: if isStudent() && 
        isDocumentInMyDepartment();
      
      // Staff can read notes in subjects they have access to
      allow read: if isStaff() && 
        hasSubjectAccess(resource.data.subjectId);
      
      // Admins can read all notes
      allow read: if isAdmin();
      
      // Only admins and assigned staff can create notes
      allow create: if isAdmin() || 
        (isStaff() && hasSubjectAccess(request.resource.data.subjectId));
      
      // Only admins and assigned staff can update notes
      allow update: if isAdmin() || 
        (isStaff() && hasSubjectAccess(resource.data.subjectId));
      
      // Only admins can delete notes
      allow delete: if isAdmin();
    }
    ```
    
    Note: `request.resource` refers to the document being written (for create/update).
    `resource` refers to the existing document (for read/update/delete).
    
    If your data structure is different, adjust the field names (e.g., subject_id vs subjectId).
  </action>
  <verify>
    1. Read firestore.rules to verify module/note rules
    2. Check that students can only read their department's notes
    3. Check that staff can only modify notes in their subjects
    4. Check that admins have full access
  </verify>
  <done>Module and note rules added with RBAC enforcement</done>
</task>

<task type="auto">
  <name>Task 4: Add data validation rules</name>
  <files>firestore.rules</files>
  <action>
    Add validation rules to ensure data integrity when creating/updating documents.
    
    These rules run after auth checks and validate the document structure.
    
    ```javascript
    // ========== VALIDATION FUNCTIONS ==========
    
    // Validate user document structure
    function isValidUser(user) {
      return user.size() >= 5 &&  // Minimum required fields
        user.keys().hasAll(['uid', 'email', 'role', 'status']) &&
        user.role in ['admin', 'staff', 'student'] &&
        user.status in ['active', 'disabled'];
    }
    
    // Validate department document
    function isValidDepartment(dept) {
      return dept.keys().hasAll(['name', 'code']) &&
        dept.name is string &&
        dept.code is string;
    }
    
    // Validate note document
    function isValidNote(note) {
      return note.keys().hasAll(['title', 'content', 'subjectId', 'departmentId']) &&
        note.title is string &&
        note.content is string &&
        note.subjectId is string &&
        note.departmentId is string;
    }
    
    // ========== UPDATE USER RULES WITH VALIDATION ==========
    
    match /users/{userId} {
      allow get: if isAuthenticated() && currentUserId() == userId;
      allow list: if isAdmin();
      
      // Validate user data on create/update
      allow create: if isAdmin() && isValidUser(request.resource.data);
      allow update: if isAdmin() && isValidUser(request.resource.data);
      allow delete: if isAdmin();
    }
    
    // ========== UPDATE NOTE RULES WITH VALIDATION ==========
    
    match /notes/{noteId} {
      // ... existing read rules ...
      
      // Validate note data on create/update
      allow create: if (isAdmin() || 
        (isStaff() && hasSubjectAccess(request.resource.data.subjectId))) &&
        isValidNote(request.resource.data);
      
      allow update: if (isAdmin() || 
        (isStaff() && hasSubjectAccess(resource.data.subjectId))) &&
        isValidNote(request.resource.data);
      
      allow delete: if isAdmin();
    }
    ```
    
    Add validation for other collections as needed based on your schema.
  </action>
  <verify>
    1. Read firestore.rules to verify validation functions
    2. Check that isValidUser enforces required fields
    3. Check that create/update operations validate data
  </verify>
  <done>Data validation rules added for user and note documents</done>
</task>

<task type="auto">
  <name>Task 5: Create firebase.json for CLI deployment</name>
  <files>firebase.json</files>
  <action>
    Create firebase.json configuration file for Firebase CLI deployment.
    
    This file tells the Firebase CLI where to find rules and indexes.
    
    ```json
    {
      "firestore": {
        "rules": "firestore.rules",
        "indexes": "firestore.indexes.json"
      },
      "emulators": {
        "firestore": {
          "port": 8080
        },
        "auth": {
          "port": 9099
        },
        "ui": {
          "enabled": true,
          "port": 4000
        }
      }
    }
    ```
    
    Also create firestore.indexes.json for composite indexes:
    ```json
    {
      "indexes": [
        {
          "collectionGroup": "notes",
          "queryScope": "COLLECTION",
          "fields": [
            {
              "fieldPath": "departmentId",
              "order": "ASCENDING"
            },
            {
              "fieldPath": "createdAt",
              "order": "DESCENDING"
            }
          ]
        },
        {
          "collectionGroup": "users",
          "queryScope": "COLLECTION",
          "fields": [
            {
              "fieldPath": "role",
              "order": "ASCENDING"
            },
            {
              "fieldPath": "departmentId",
              "order": "ASCENDING"
            }
          ]
        }
      ],
      "fieldOverrides": []
    }
    ```
    
    These indexes optimize common queries:
    - Notes by department, sorted by date
    - Users by role and department
    
    Customize based on your actual query patterns.
  </action>
  <verify>
    1. Check firebase.json exists and points to firestore.rules
    2. Check firestore.indexes.json exists with indexes
    3. Verify emulator ports are specified (8080 for Firestore, 9099 for Auth)
  </verify>
  <done>firebase.json and firestore.indexes.json created for CLI deployment</done>
</task>

<task type="auto">
  <name>Task 6: Document security rules architecture</name>
  <files>documentations/security-rules.md</files>
  <action>
    Create documentation explaining the security rules architecture.
    
    ```markdown
    # Firestore Security Rules Architecture

    ## Overview

    This document explains the RBAC (Role-Based Access Control) security rules
    for AURA-NOTES-MANAGER.

    ## Architecture: Hybrid RBAC Model

    We use a hybrid approach combining two Firebase features:

    1. **Custom Claims** (in JWT tokens): For global roles (admin, staff, student)
       - Pros: Instant access, no database reads, free
       - Cons: Limited to 1KB total, requires token refresh to update
       - Used for: High-level role checks

    2. **Firestore Documents**: For granular permissions (departmentId, subjectIds)
       - Pros: Unlimited size, instant updates, dynamic
       - Cons: Requires database read (costs money), adds latency
       - Used for: Resource-specific access control

    ## Role Permissions Matrix

    | Collection | Admin | Staff | Student |
    |------------|-------|-------|---------|
    | users | CRUD | Read self | Read self |
    | departments | CRUD | Read | Read |
    | semesters | CRUD | Read | Read |
    | subjects | CRUD | Read/Update assigned | Read |
    | modules | CRUD | Read/Update assigned subjects | Read |
    | notes | CRUD | CRUD assigned subjects | Read own department |

    ## Helper Functions

    ### Authentication Checks
    - `isAuthenticated()`: User is logged in
    - `currentUserId()`: Get current user's UID
    - `hasRole(role)`: Check Custom Claim for role

    ### Role Checks (Custom Claims)
    - `isAdmin()`: User is admin
    - `isStaff()`: User is staff
    - `isStudent()`: User is student

    ### Granular Permission Checks (Firestore)
    - `getUser(userId)`: Get user document from Firestore
    - `isInDepartment(departmentId)`: Check if user's department matches
    - `hasSubjectAccess(subjectId)`: Check if subjectId is in user's subjectIds
    - `isDocumentInMyDepartment()`: Check if document's department matches user's

    ## Security Rules Flow

    1. **Authentication**: Is the user logged in?
    2. **Authorization**: Does the user have the required role?
    3. **Granular Check**: Does the user have access to this specific resource?
    4. **Validation**: Is the data being written valid?

    ## Best Practices Implemented

    1. **Deny by Default**: All access denied unless explicitly allowed
    2. **Fail Fast**: Check Custom Claims before expensive Firestore lookups
    3. **Least Privilege**: Users only get minimum required access
    4. **Defense in Depth**: Rules protect even if backend auth is bypassed

    ## Deployment

    ```bash
    # Deploy rules to production
    firebase deploy --only firestore:rules

    # Test locally first
    firebase emulators:start --only firestore
    ```

    ## Testing

    See: 02-03-PLAN.md for security rules unit tests
    ```
  </action>
  <verify>
    Read documentations/security-rules.md and verify it explains:
    - Hybrid RBAC model
    - Helper functions
    - Role permissions matrix
    - Deployment commands
  </verify>
  <done>Security rules architecture documented</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] firestore.rules exists with rules_version = '2'
- [ ] Helper functions defined (isAdmin, isStaff, hasSubjectAccess, etc.)
- [ ] Users collection rules implement RBAC
- [ ] Departments, semesters, subjects have read access with auth, write for admins
- [ ] Modules and notes enforce granular permissions
- [ ] Data validation functions exist
- [ ] firebase.json and firestore.indexes.json created
- [ ] documentations/security-rules.md explains the architecture
- [ ] No syntax errors in firestore.rules (run firebase deploy --dry-run if possible)
</verification>

<success_criteria>
- All tasks completed
- firestore.rules implements complete RBAC logic
- Helper functions are reusable and clear
- Rules enforce least-privilege principle
- Documentation explains the hybrid model
- Ready for testing in 02-03
</success_criteria>

<output>
After completion, create `.planning/firebase-rbac-migration/phases/02-firestore-schema-rules/02-02-SUMMARY.md`
</output>
