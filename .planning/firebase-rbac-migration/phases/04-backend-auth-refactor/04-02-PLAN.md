---
phase: 04-backend-auth-refactor
type: execute
---

<objective>
Create an endpoint to sync Firebase Authentication users with Firestore user documents on first login, ensuring user metadata is properly initialized.

Purpose: When a user signs in via Firebase Auth for the first time, we need to create their corresponding Firestore document with role and permissions. This endpoint handles that synchronization and provides user management capabilities for admins.
Output: POST /api/auth/sync endpoint for user synchronization and updated user creation flow that works with both Firebase Auth and Firestore.
</objective>

<execution_context>
@~/.Opencode/skills/create-plans/workflows/execute-phase.md
@~/.Opencode/skills/create-plans/templates/summary.md
</execution_context>

<context>
@.planning/firebase-rbac-migration/BRIEF.md
@.planning/firebase-rbac-migration/ROADMAP.md
@FIREBASE_RBAC_MIGRATION_PLAN.md
@api/auth.py
@api/users.py
@api/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create user sync endpoint structure</name>
  <files>api/auth_sync.py (new file)</files>
  <action>
    Create a new file for authentication synchronization endpoints.
    
    ```python
    """
    ============================================================================
    FILE: auth_sync.py
    LOCATION: api/auth_sync.py
    ============================================================================

    PURPOSE:
        Handle synchronization between Firebase Auth and Firestore users

    ROLE IN PROJECT:
        - Create Firestore user document on first login
        - Sync user metadata between Auth and Firestore
        - Handle user profile updates

    DEPENDENCIES:
        - firebase_admin.auth
        - api.config.get_db, get_auth
        - api.auth.FirestoreUser, CreateUserInput
    ============================================================================
    """

    from fastapi import APIRouter, Depends, HTTPException, status
    from pydantic import BaseModel, Field
    from typing import Optional, Literal
    from datetime import datetime

    from api.config import get_db, get_auth
    from api.auth import (
        FirestoreUser,
        CreateUserInput,
        get_current_user,
        require_admin,
    )

    router = APIRouter()

    # Request/Response models
    class SyncUserRequest(BaseModel):
        """Request to sync Firebase Auth user with Firestore."""
        # Optional fields that can be set on first sync
        departmentId: Optional[str] = Field(None, description="Department assignment")
        subjectIds: Optional[list[str]] = Field(default_factory=list, description="Subject assignments")
        displayName: Optional[str] = Field(None, description="User display name")

    class SyncUserResponse(BaseModel):
        """Response after user sync."""
        message: str
        user: FirestoreUser
        isNewUser: bool

    class UserProfileUpdate(BaseModel):
        """Request to update user profile."""
        displayName: Optional[str] = None
        departmentId: Optional[str] = None
        subjectIds: Optional[list[str]] = None

    ```
    
    This file will contain all user synchronization endpoints.
  </action>
  <verify>
    1. Check api/auth_sync.py exists
    2. Verify imports are correct
    3. Verify router is created
    4. Test: python -c "from api.auth_sync import router; print('OK')"
  </verify>
  <done>auth_sync.py file created with imports and request/response models</done>
</task>

<task type="auto">
  <name>Task 2: Implement POST /api/auth/sync endpoint</name>
  <files>api/auth_sync.py</files>
  <action>
    Implement the user sync endpoint that creates Firestore document on first login.
    
    ```python
    @router.post("/api/auth/sync", response_model=SyncUserResponse)
    async def sync_user(
        request: Optional[SyncUserRequest] = None,
        current_user: FirestoreUser = Depends(get_current_user)
    ):
        """
        Sync Firebase Auth user with Firestore user document.
        
        This endpoint should be called after a user signs in via Firebase Auth
        on the frontend. It:
        1. Checks if user already exists in Firestore
        2. If not, creates a new user document with metadata
        3. If yes, returns existing user data
        
        The first user to sign in (admin setup) can specify role and permissions.
        Subsequent users must be created by an admin.
        
        Args:
            request: Optional fields for new user (departmentId, subjectIds, displayName)
            current_user: The authenticated user (from Firebase Auth token)
            
        Returns:
            SyncUserResponse with user data and isNewUser flag
        """
        db = get_db()
        auth_client = get_auth()
        
        # Get user UID from Firebase Auth
        uid = current_user.uid
        
        # Check if user already exists in Firestore
        user_ref = db.collection('users').document(uid)
        user_doc = user_ref.get()
        
        if user_doc.exists:
            # User already exists, return existing data
            user_data = user_doc.to_dict()
            user_data['uid'] = uid
            
            return SyncUserResponse(
                message="User already exists",
                user=FirestoreUser(**user_data),
                isNewUser=False
            )
        
        # User doesn't exist - create new Firestore document
        # Get user info from Firebase Auth
        try:
            auth_user = auth_client.get_user(uid)
        except Exception as e:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail=f"Failed to get user from Firebase Auth: {str(e)}"
            )
        
        # Check if this is the first user (admin setup)
        # Count existing users
        existing_users = list(db.collection('users').limit(1).stream())
        is_first_user = len(existing_users) == 0
        
        # Determine role
        if is_first_user:
            # First user becomes admin automatically
            role = 'admin'
        else:
            # Check for Custom Claims (set by admin during user creation)
            custom_claims = auth_user.custom_claims or {}
            role = custom_claims.get('role', 'student')  # Default to student
        
        # Create user data
        user_data = {
            'uid': uid,
            'email': auth_user.email or '',
            'displayName': request.displayName if request else (auth_user.display_name or ''),
            'role': role,
            'status': 'active',
            'departmentId': request.departmentId if request else None,
            'subjectIds': request.subjectIds if request else [],
            'createdAt': datetime.utcnow(),
            'updatedAt': datetime.utcnow(),
            '_v': 1,  # Schema version
        }
        
        # Save to Firestore
        user_ref.set(user_data)
        
        return SyncUserResponse(
            message="User created successfully",
            user=FirestoreUser(**user_data),
            isNewUser=True
        )
    ```
    
    Key features:
    - Checks if user already exists (idempotent)
    - First user becomes admin automatically
    - Gets user info from Firebase Auth
    - Respects Custom Claims for role
    - Creates Firestore document with metadata
    - Returns isNewUser flag for frontend handling
  </action>
  <verify>
    1. Read api/auth_sync.py to verify endpoint exists
    2. Verify it uses get_current_user dependency
    3. Verify it creates user in Firestore if not exists
    4. Verify first user becomes admin logic
  </verify>
  <done>POST /api/auth/sync endpoint implemented with first-user-admin logic</done>
</task>

<task type="auto">
  <name>Task 3: Implement admin user creation endpoint</name>
  <files>api/auth_sync.py</files>
  <action>
    Create an admin-only endpoint to create users in both Firebase Auth and Firestore.
    
    ```python
    class CreateFirebaseUserRequest(BaseModel):
        """Request to create a new user via admin."""
        email: str = Field(..., description="User email address")
        password: str = Field(..., min_length=6, description="Initial password")
        displayName: str = Field(..., description="User display name")
        role: Literal['admin', 'staff', 'student'] = Field(..., description="User role")
        departmentId: Optional[str] = Field(None, description="Department ID")
        subjectIds: list[str] = Field(default_factory=list, description="Subject IDs for staff")
        sendEmailVerification: bool = Field(False, description="Send email verification")
        
        @validator('password')
        def validate_password(cls, v):
            if len(v) < 6:
                raise ValueError('Password must be at least 6 characters')
            return v
        
        @validator('subjectIds')
        def validate_subjects_for_staff(cls, v, values):
            if values.get('role') == 'staff' and not v:
                raise ValueError('subjectIds required for staff role')
            return v

    class CreateFirebaseUserResponse(BaseModel):
        """Response after creating Firebase user."""
        message: str
        uid: str
        user: FirestoreUser

    @router.post("/api/admin/users", response_model=CreateFirebaseUserResponse)
    async def create_firebase_user(
        request: CreateFirebaseUserRequest,
        admin_user: FirestoreUser = Depends(require_admin)
    ):
        """
        Create a new user in Firebase Auth and Firestore (admin only).
        
        This endpoint:
        1. Creates user in Firebase Authentication
        2. Sets Custom Claims for role
        3. Creates Firestore user document with metadata
        4. Optionally sends email verification
        
        Args:
            request: User creation details
            admin_user: The admin performing the creation
            
        Returns:
            CreateFirebaseUserResponse with new user's UID and data
        """
        db = get_db()
        auth_client = get_auth()
        
        try:
            # Step 1: Create user in Firebase Auth
            auth_user = auth_client.create_user(
                email=request.email,
                password=request.password,
                display_name=request.displayName,
                email_verified=False,
            )
            
            uid = auth_user.uid
            
            # Step 2: Set Custom Claims for role
            auth_client.set_custom_user_claims(uid, {
                'role': request.role,
            })
            
            # Step 3: Create Firestore document
            user_data = {
                'uid': uid,
                'email': request.email,
                'displayName': request.displayName,
                'role': request.role,
                'status': 'active',
                'departmentId': request.departmentId,
                'subjectIds': request.subjectIds,
                'createdAt': datetime.utcnow(),
                'updatedAt': datetime.utcnow(),
                '_v': 1,
            }
            
            db.collection('users').document(uid).set(user_data)
            
            # Step 4: Optionally send email verification
            if request.sendEmailVerification:
                # Generate email verification link
                verification_link = auth_client.generate_email_verification_link(
                    request.email
                )
                # In production, you'd send this via your email service
                # For now, just log it
                print(f"Email verification link: {verification_link}")
            
            return CreateFirebaseUserResponse(
                message="User created successfully",
                uid=uid,
                user=FirestoreUser(**user_data)
            )
            
        except auth.EmailAlreadyExistsError:
            raise HTTPException(
                status_code=status.HTTP_409_CONFLICT,
                detail="User with this email already exists"
            )
        except auth.InvalidEmailError:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid email address"
            )
        except auth.WeakPasswordError:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Password is too weak"
            )
        except Exception as e:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail=f"Failed to create user: {str(e)}"
            )
    ```
    
    This endpoint:
    - Creates user in Firebase Auth (email/password)
    - Sets Custom Claims for role (used in token)
    - Creates Firestore document with full metadata
    - Handles validation (role constraints, password strength)
    - Proper error handling for Firebase exceptions
  </action>
  <verify>
    1. Read api/auth_sync.py to verify admin endpoint exists
    2. Verify it uses require_admin dependency
    3. Verify it calls auth.create_user() and auth.set_custom_user_claims()
    4. Verify it creates Firestore document
  </verify>
  <done>Admin user creation endpoint implemented with Firebase Auth integration</done>
</task>

<task type="auto">
  <name>Task 4: Implement user update and delete endpoints</name>
  <files>api/auth_sync.py</files>
  <action>
    Add endpoints for updating and deleting users (admin only).
    
    ```python
    @router.put("/api/admin/users/{uid}", response_model=FirestoreUser)
    async def update_firebase_user(
        uid: str,
        request: UserProfileUpdate,
        admin_user: FirestoreUser = Depends(require_admin)
    ):
        """
        Update an existing user (admin only).
        
        Updates both Firebase Auth and Firestore.
        """
        db = get_db()
        auth_client = get_auth()
        
        # Check if user exists
        user_ref = db.collection('users').document(uid)
        user_doc = user_ref.get()
        
        if not user_doc.exists:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="User not found"
            )
        
        try:
            # Update Firebase Auth (display name only)
            update_props = {}
            if request.displayName:
                update_props['display_name'] = request.displayName
            
            if update_props:
                auth_client.update_user(uid, **update_props)
            
            # Update Firestore
            update_data = {
                'updatedAt': datetime.utcnow(),
            }
            
            if request.displayName is not None:
                update_data['displayName'] = request.displayName
            if request.departmentId is not None:
                update_data['departmentId'] = request.departmentId
            if request.subjectIds is not None:
                update_data['subjectIds'] = request.subjectIds
            
            user_ref.update(update_data)
            
            # Return updated user
            updated_doc = user_ref.get()
            user_data = updated_doc.to_dict()
            user_data['uid'] = uid
            
            return FirestoreUser(**user_data)
            
        except Exception as e:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail=f"Failed to update user: {str(e)}"
            )

    @router.delete("/api/admin/users/{uid}")
    async def delete_firebase_user(
        uid: str,
        admin_user: FirestoreUser = Depends(require_admin)
    ):
        """
        Delete a user from Firebase Auth and Firestore (admin only).
        
        WARNING: This is permanent and cannot be undone!
        """
        db = get_db()
        auth_client = get_auth()
        
        # Prevent admin from deleting themselves
        if uid == admin_user.uid:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Cannot delete your own account"
            )
        
        try:
            # Delete from Firebase Auth
            auth_client.delete_user(uid)
            
            # Delete from Firestore
            db.collection('users').document(uid).delete()
            
            return {"message": "User deleted successfully"}
            
        except auth.UserNotFoundError:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="User not found in Firebase Auth"
            )
        except Exception as e:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail=f"Failed to delete user: {str(e)}"
            )
    ```
    
    These endpoints:
    - Update both Auth and Firestore
    - Delete from both systems
    - Prevent self-deletion
    - Proper error handling
  </action>
  <verify>
    1. Verify PUT and DELETE endpoints exist
    2. Verify they use require_admin
    3. Verify they update/delete both Auth and Firestore
  </verify>
  <done>User update and delete endpoints implemented</done>
</task>

<task type="auto">
  <name>Task 5: Mount auth_sync router in main application</name>
  <files>api/main.py</files>
  <action>
    Mount the auth_sync router in the main FastAPI application.
    
    ```python
    # In api/main.py
    
    from api.auth_sync import router as auth_sync_router
    
    # ... existing router imports ...
    
    app = FastAPI(
        title="AURA Notes Manager API",
        # ... other config
    )
    
    # ... existing middleware ...
    
    # Include routers
    app.include_router(auth_sync_router)
    # ... other routers ...
    ```
    
    Also update any existing user router references if needed:
    - Remove old mock-based user creation endpoints
    - Keep list/get endpoints but ensure they use new auth dependencies
    
    The auth_sync router provides:
    - POST /api/auth/sync - For user self-registration
    - POST /api/admin/users - For admin user creation
    - PUT /api/admin/users/{uid} - For admin user updates
    - DELETE /api/admin/users/{uid} - For admin user deletion
  </action>
  <verify>
    1. Read api/main.py to verify auth_sync router is included
    2. Verify all routes are accessible:
       - Test: python -c "from api.main import app; print('OK')"
       - Or start server and check /docs for new endpoints
  </verify>
  <done>auth_sync router mounted in main application</done>
</task>

<task type="auto">
  <name>Task 6: Create tests for user sync endpoints</name>
  <files>tests/test_auth_sync.py</files>
  <action>
    Create comprehensive tests for the user synchronization endpoints.
    
    ```python
    """
    ============================================================================
    FILE: test_auth_sync.py
    LOCATION: tests/test_auth_sync.py
    ============================================================================

    PURPOSE:
        Tests for user synchronization endpoints
    ============================================================================
    """

    import pytest
    from fastapi.testclient import TestClient
    from unittest.mock import patch, MagicMock
    from api.main import app

    client = TestClient(app)

    class TestUserSync:
        """Tests for /api/auth/sync endpoint."""
        
        def test_sync_new_user(self):
            """Test syncing a new user creates Firestore document."""
            # Mock Firebase Auth user
            mock_auth_user = MagicMock()
            mock_auth_user.email = "newuser@aura.edu"
            mock_auth_user.display_name = "New User"
            mock_auth_user.custom_claims = {}
            
            # Mock get_user to return this
            # ... test implementation ...
            pass
        
        def test_sync_existing_user(self):
            """Test syncing existing user returns existing data."""
            # Should return isNewUser=false
            pass
        
        def test_first_user_becomes_admin(self):
            """Test that first user gets admin role."""
            # When no users exist, new user should be admin
            pass

    class TestAdminUserCreation:
        """Tests for /api/admin/users endpoint."""
        
        def test_admin_can_create_user(self):
            """Test admin can create user in Firebase Auth and Firestore."""
            # Mock require_admin to return admin user
            # Mock auth.create_user
            # Mock Firestore set
            # Verify both Auth and Firestore called
            pass
        
        def test_non_admin_cannot_create_user(self):
            """Test non-admin is forbidden from creating users."""
            # Should return 403
            pass
        
        def test_duplicate_email_rejected(self):
            """Test creating user with existing email returns 409."""
            # Mock auth.create_user to raise EmailAlreadyExistsError
            pass
        
        def test_staff_requires_subjects(self):
            """Test that staff role requires subjectIds."""
            # Validation should fail
            pass

    class TestUserUpdate:
        """Tests for user update endpoint."""
        
        def test_admin_can_update_user(self):
            """Test admin can update user metadata."""
            pass
        
        def test_update_syncs_auth_and_firestore(self):
            """Test that updates apply to both systems."""
            pass

    class TestUserDeletion:
        """Tests for user delete endpoint."""
        
        def test_admin_can_delete_user(self):
            """Test admin can delete user."""
            pass
        
        def test_self_deletion_prevented(self):
            """Test admin cannot delete own account."""
            pass
        
        def test_deletion_removes_from_both_systems(self):
            """Test that deletion removes from Auth and Firestore."""
            pass
    ```
    
    These tests verify:
    - User sync creates Firestore document
    - First user becomes admin
    - Admin can create users in both systems
    - Validation works (duplicate emails, staff needs subjects)
    - Updates sync to both systems
    - Deletion removes from both systems
  </action>
  <verify>
    1. Check tests/test_auth_sync.py exists
    2. Run: pytest tests/test_auth_sync.py -v
    3. Fix any failing tests
  </verify>
  <done>User sync endpoint tests created and passing</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] api/auth_sync.py created with router
- [ ] POST /api/auth/sync endpoint handles first login
- [ ] First user automatically becomes admin
- [ ] POST /api/admin/users creates users in both Auth and Firestore
- [ ] Custom Claims set for role during user creation
- [ ] PUT /api/admin/users/{uid} updates both systems
- [ ] DELETE /api/admin/users/{uid} deletes from both systems
- [ ] Router mounted in api/main.py
- [ ] Tests created for all endpoints
- [ ] Proper error handling for all Firebase exceptions
- [ ] Validation enforces role constraints
</verification>

<success_criteria>
- All tasks completed
- User sync endpoint handles first login scenario
- Admin user creation works with Firebase Auth
- Custom Claims properly set for RBAC
- Update and delete endpoints sync both systems
- Router properly integrated
- Tests verify all functionality
- Proper validation and error handling
- Ready for 04-03 (Remove mock login)
</success_criteria>

<output>
After completion, create `.planning/firebase-rbac-migration/phases/04-backend-auth-refactor/04-02-SUMMARY.md`
</output>
