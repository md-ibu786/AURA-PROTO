---
phase: 03-data-migration
type: execute
---

<objective>
Execute the data migration script safely and verify data integrity in Firebase Console. Create rollback procedure documentation.

Purpose: Safely transfer mock data to production Firestore, verify the migration was successful, and document the process for future reference.
Output: Completed migration with verified data in Firebase Console and comprehensive documentation of the process.
</objective>

<execution_context>
@~/.Opencode/skills/create-plans/workflows/execute-phase.md
@~/.Opencode/skills/create-plans/templates/summary.md
@~/.Opencode/skills/create-plans/references/checkpoints.md
</execution_context>

<context>
@.planning/firebase-rbac-migration/BRIEF.md
@.planning/firebase-rbac-migration/ROADMAP.md
@FIREBASE_RBAC_MIGRATION_PLAN.md
@tools/seed_firestore.py
@tools/backup_firestore.py
@tools/migration_config.py
</context>

<tasks>

<task type="checkpoint:human-action" gate="blocking">
  <name>Task 1: Create Cloud Storage bucket for backups</name>
  <action>
    Before running any migration, we need a backup location.
    
    1. Go to https://console.cloud.google.com/storage/browser
    2. Make sure your Firebase project is selected
    3. Click "CREATE BUCKET"
    4. Enter bucket name: "[your-project-id]-firestore-backups"
       - Must be globally unique
       - Example: "aura-notes-manager-abc123-firestore-backups"
    5. Choose location type: "Region" (select same region as your Firestore)
    6. Choose storage class: "Standard"
    7. Access control: "Uniform"
    8. Advanced settings (optional):
       - Enable object versioning (recommended)
       - Set retention policy (e.g., 30 days)
    9. Click "CREATE"
    
    Note the full bucket name (gs://...) for the backup script.
  </action>
  <verify>
    Bucket appears in Cloud Storage browser with green checkmark (indicates ready).
  </verify>
  <done>Cloud Storage bucket created for Firestore backups</done>
  <resume-signal>Type "done" when bucket is created</resume-signal>
</task>

<task type="auto">
  <name>Task 2: Run backup script</name>
  <files>tools/backup_firestore.py</files>
  <action>
    Run the backup script to create a point-in-time snapshot before migration.
    
    Prerequisites:
    - Google Cloud SDK installed and authenticated: gcloud auth login
    - Cloud Storage bucket created
    
    Run the backup:
    ```bash
    python tools/backup_firestore.py --bucket gs://[your-bucket-name]
    ```
    
    Or without specifying bucket (it will prompt):
    ```bash
    python tools/backup_firestore.py
    ```
    
    This will:
    1. Export all collections (users, departments, semesters, subjects, modules, notes)
    2. Save to gs://[bucket]/firestore-backup-[timestamp]/
    3. Output the backup path for reference
    
    Save the backup path - you'll need it for rollback if something goes wrong.
    
    Note: If this is the first migration, Firestore might be empty. The backup will complete quickly with no data. This is still important for the process.
  </action>
  <verify>
    Check that:
    1. gcloud command succeeds
    2. Backup path is displayed
    3. No errors in output
  </verify>
  <done>Backup created successfully with path recorded</done>
</task>

<task type="auto">
  <name>Task 3: Run migration in dry-run mode</name>
  <files>tools/seed_firestore.py</files>
  <action>
    Test the migration script without making actual changes.
    
    ```bash
    python tools/seed_firestore.py --dry-run
    ```
    
    This will:
    1. Load mock_db.json
    2. Transform documents according to mappings
    3. Show what WOULD be done (no actual writes)
    4. Display statistics
    
    Review the output carefully:
    - Verify document counts match expected
    - Check for any errors or warnings
    - Ensure field mappings are correct
    - Look for any unexpected transformations
    
    If issues found:
    1. Fix tools/migration_config.py field mappings
    2. Re-run dry-run
    3. Repeat until output looks correct
    
    Common issues to watch for:
    - Missing required fields
    - Incorrect field name mappings
    - Type mismatches
    - Documents being skipped unexpectedly
  </action>
  <verify>
    Run dry-run and verify:
    1. No errors in output
    2. Document counts match mock_db.json
    3. Sample documents show correct field names
    4. Schema version is set correctly
  </verify>
  <done>Dry-run completed successfully with no errors</done>
</task>

<task type="checkpoint:decision" gate="blocking">
  <name>Task 4: Execute actual migration</name>
  <decision>Ready to execute the real migration to Firestore?</decision>
  <context>
    We've completed:
    - Created backup ✓
    - Ran dry-run successfully ✓
    - Verified field mappings ✓
    
    The migration will write to production Firestore.
    Backup is available for rollback if needed.
  </context>
  <options>
    <option id="yes-migrate">
      <name>Execute migration</name>
      <pros>Proceed with migration, writes data to Firestore</pros>
      <cons>Cannot be undone except via backup restore</cons>
    </option>
    <option id="no-fix-issues">
      <name>Fix issues first</name>
      <pros>Can adjust mappings before proceeding</pros>
      <cons>Delays migration</cons>
    </option>
  </options>
  <resume-signal>Select: yes-migrate or no-fix-issues</resume-signal>
</task>

<task type="auto">
  <name>Task 5: Run actual migration</name>
  <files>tools/seed_firestore.py</files>
  <action>
    Execute the actual migration to Firestore.
    
    ```bash
    python tools/seed_firestore.py
    ```
    
    This will:
    1. Initialize Firebase with serviceAccountKey.json
    2. Load mock_db.json
    3. Migrate collections in order (users -> departments -> ...)
    4. Use BulkWriter for efficient batch operations
    5. Track progress and log statistics
    6. Record migration state in _migrations collection
    
    Expected output:
    ```
    INFO - Starting Firestore migration
    INFO - Firebase initialized successfully
    INFO - Loaded mock data with X top-level keys
    INFO - Migrating Y documents to users
    INFO - Migrating Z documents to departments
    ...
    INFO - Flushing writes to Firestore...
    ==================================================
    INFO - Migration complete!
      Created: A
      Updated: B
      Skipped: C
      Errors:  D
    ==================================================
    ```
    
    If errors occur:
    1. Note the error message
    2. Fix the issue in migration_config.py
    3. Re-run (script is idempotent, will skip already-migrated docs)
  </action>
  <verify>
    Run migration and verify:
    1. Firebase initializes successfully
    2. No critical errors during migration
    3. Statistics show expected document counts
    4. Migration completes with success message
  </verify>
  <done>Migration executed successfully with documents created/updated</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 6: Verify data in Firebase Console</name>
  <what-built>
    Data has been migrated to Firestore. Now we need to verify it in Firebase Console.
  </what-built>
  <how-to-verify>
    1. Go to https://console.firebase.google.com/
    2. Select your project
    3. Navigate to "Firestore Database" in the left sidebar
    4. Verify each collection:
       - Click on "users" collection
       - Check that user documents exist with correct fields:
         - uid matches Firebase Auth UID
         - email, displayName populated
         - role is 'admin', 'staff', or 'student'
         - status is 'active' or 'disabled'
         - departmentId and subjectIds present (where applicable)
         - createdAt and updatedAt timestamps
         - _v = 1 (schema version)
       
       - Click on "departments" collection
       - Verify department data
       
       - Check "notes" collection
       - Verify notes have proper references
    
    5. Check document counts match expected:
       - Compare with mock_db.json counts
    
    6. Spot-check a few documents:
       - Open a user document
       - Verify field names and values
       - Check data types are correct
    
    7. Check _migrations collection:
       - Should have a document with:
         - started_at timestamp
         - completed_at timestamp
         - status: 'completed'
         - stats object with counts
  </how-to-verify>
  <resume-signal>Type "verified" when data looks correct in Firebase Console, or describe issues to fix</resume-signal>
</task>

<task type="auto">
  <name>Task 7: Create verification script</name>
  <files>tools/verify_migration.py</files>
  <action>
    Create an automated verification script to check migration integrity.
    
    ```python
    """
    ============================================================================
    FILE: verify_migration.py
    LOCATION: tools/verify_migration.py
    ============================================================================

    PURPOSE:
        Verify data integrity after Firestore migration

    ROLE IN PROJECT:
        Automated checks to ensure migration was successful

    DEPENDENCIES:
        - firebase-admin
        - mock_db.json (for comparison)
    ============================================================================
    """

    import json
    import logging
    from pathlib import Path
    from typing import Dict, List, Any

    import firebase_admin
    from firebase_admin import credentials, firestore

    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger(__name__)

    PROJECT_ROOT = Path(__file__).parent.parent
    MOCK_DB_PATH = PROJECT_ROOT / 'mock_db.json'
    SERVICE_ACCOUNT_PATH = PROJECT_ROOT / 'serviceAccountKey.json'

    class MigrationVerifier:
        def __init__(self):
            self.db = None
            self.issues = []
        
        def initialize_firebase(self):
            if not firebase_admin._apps:
                cred = credentials.Certificate(str(SERVICE_ACCOUNT_PATH))
                firebase_admin.initialize_app(cred)
            self.db = firestore.client()
        
        def load_mock_data(self) -> Dict[str, Any]:
            with open(MOCK_DB_PATH, 'r') as f:
                return json.load(f)
        
        def verify_collection_counts(self, mock_data: Dict) -> bool:
            """Verify document counts match between mock and Firestore."""
            logger.info("Verifying collection counts...")
            all_match = True
            
            for collection, docs in mock_data.items():
                if not isinstance(docs, dict):
                    continue
                
                mock_count = len(docs)
                firestore_count = len(list(self.db.collection(collection).stream()))
                
                if mock_count != firestore_count:
                    logger.error(
                        f"{collection}: Count mismatch - "
                        f"mock: {mock_count}, firestore: {firestore_count}"
                    )
                    all_match = False
                else:
                    logger.info(f"{collection}: {firestore_count} documents ✓")
            
            return all_match
        
        def verify_user_schema(self) -> bool:
            """Verify user documents have correct schema."""
            logger.info("Verifying user schema...")
            users = self.db.collection('users').stream()
            
            required_fields = ['uid', 'email', 'role', 'status', '_v']
            all_valid = True
            
            for user in users:
                data = user.to_dict()
                missing = [f for f in required_fields if f not in data]
                
                if missing:
                    logger.error(f"User {user.id} missing fields: {missing}")
                    all_valid = False
                
                if data.get('role') not in ['admin', 'staff', 'student']:
                    logger.error(f"User {user.id} has invalid role: {data.get('role')}")
                    all_valid = False
            
            if all_valid:
                logger.info("User schema: All valid ✓")
            
            return all_valid
        
        def verify_migration_record(self) -> bool:
            """Verify migration was recorded."""
            logger.info("Verifying migration record...")
            
            docs = (
                self.db.collection('_migrations')
                .where('status', '==', 'completed')
                .order_by('completed_at', direction='DESCENDING')
                .limit(1)
                .stream()
            )
            
            for doc in docs:
                data = doc.to_dict()
                logger.info(f"Found migration record: {doc.id}")
                logger.info(f"  Started: {data.get('started_at')}")
                logger.info(f"  Completed: {data.get('completed_at')}")
                logger.info(f"  Stats: {data.get('stats')}")
                return True
            
            logger.error("No completed migration record found")
            return False
        
        def run_all_checks(self) -> bool:
            """Run all verification checks."""
            logger.info("=" * 50)
            logger.info("Starting migration verification")
            logger.info("=" * 50)
            
            self.initialize_firebase()
            mock_data = self.load_mock_data()
            
            checks = [
                ("Collection counts", self.verify_collection_counts(mock_data)),
                ("User schema", self.verify_user_schema()),
                ("Migration record", self.verify_migration_record()),
            ]
            
            logger.info("=" * 50)
            logger.info("Verification Results:")
            
            all_passed = True
            for name, passed in checks:
                status = "✓ PASS" if passed else "✗ FAIL"
                logger.info(f"  {name}: {status}")
                if not passed:
                    all_passed = False
            
            logger.info("=" * 50)
            
            return all_passed

    def main():
        verifier = MigrationVerifier()
        
        try:
            if verifier.run_all_checks():
                logger.info("\n✓ All verification checks passed!")
                return 0
            else:
                logger.error("\n✗ Some verification checks failed")
                return 1
        except Exception as e:
            logger.error(f"Verification failed with error: {e}")
            return 1

    if __name__ == '__main__':
        exit(main())
    ```
  </action>
  <verify>
    1. Check tools/verify_migration.py exists
    2. Run: python tools/verify_migration.py
    3. Verify all checks pass
  </verify>
  <done>Verification script created and all checks pass</done>
</task>

<task type="auto">
  <name>Task 8: Document rollback procedure</name>
  <files>documentations/migration-playbook.md</files>
  <action>
    Create comprehensive migration documentation including rollback procedures.
    
    ```markdown
    # Firestore Migration Playbook

    ## Overview

    This document describes the data migration process from mock_db.json to
    Firestore and provides rollback procedures.

    ## Pre-Migration Checklist

    - [ ] Cloud Storage bucket created for backups
    - [ ] serviceAccountKey.json downloaded and secure
    - [ ] mock_db.json is up to date
    - [ ] Firebase project configured (Phase 1 complete)
    - [ ] Security rules deployed (Phase 2 complete)

    ## Migration Process

    ### 1. Create Backup

    ```bash
    python tools/backup_firestore.py --bucket gs://[your-bucket]
    ```

    Save the backup path output.

    ### 2. Dry Run

    ```bash
    python tools/seed_firestore.py --dry-run
    ```

    Review output for errors or unexpected behavior.

    ### 3. Execute Migration

    ```bash
    python tools/seed_firestore.py
    ```

    Monitor output for errors.

    ### 4. Verify

    ```bash
    python tools/verify_migration.py
    ```

    All checks should pass.

    ### 5. Manual Console Verification

    - Open Firebase Console → Firestore Database
    - Verify document counts
    - Spot-check documents for correct data
    - Check _migrations collection has success record

    ## Rollback Procedure

    If migration fails or data is corrupted:

    ### Option 1: Restore from Backup (Recommended)

    ```bash
    # Restore from backup created before migration
    gcloud firestore import gs://[your-bucket]/firestore-backup-[timestamp]
    ```

    Note: This will OVERWRITE current Firestore data with backup data.

    ### Option 2: Partial Re-migration

    If only specific collections have issues:

    ```bash
    # Re-migrate just the users collection
    python tools/seed_firestore.py --collection users
    ```

    ### Option 3: Reset and Re-run

    **WARNING: This deletes ALL data**

    ```bash
    python tools/seed_firestore.py --reset
    ```

    You must confirm by typing "yes".

    ## Troubleshooting

    ### Issue: "Service account key not found"

    **Solution**: Download serviceAccountKey.json from Firebase Console →
    Project Settings → Service Accounts → Generate new private key.

    ### Issue: "Permission denied"

    **Solution**: Check IAM roles for service account. Must have:
    - Firebase Admin SDK Administrator Service Agent
    - Cloud Datastore User

    ### Issue: Documents not appearing

    **Possible causes**:
    - Dry-run mode is still on
    - Wrong Firebase project selected
    - Security rules blocking writes
    
    **Solution**: Check Firebase Console for errors, verify environment variables.

    ### Issue: "Rate limit exceeded"

    **Solution**: Migration uses BulkWriter with automatic throttling.
    If you see this error, wait a few minutes and re-run (it's idempotent).

    ## Schema Versioning

    Documents have `_v` field indicating schema version.

    Current version: 1

    Future migrations can check `_v` to determine if update is needed.

    ## Migration History

    Migrations are tracked in the `_migrations` collection.

    Each document contains:
    - `started_at`: Migration start timestamp
    - `completed_at`: Migration completion timestamp
    - `status`: 'completed', 'failed', or 'in_progress'
    - `stats`: Count of created/updated/skipped/errored documents
    - `schema_version`: Schema version used

    ## Re-running Migrations

    The migration script is **idempotent** - it can be safely re-run.

    On re-run:
    - Documents with `_v` >= current version are skipped
    - Documents with `_v` < current version are updated
    - New documents are created
    - Existing documents with same `_v` are skipped

    ## Post-Migration Steps

    After successful migration:

    1. Update frontend to use real Firebase (Phase 5)
    2. Update backend to verify real tokens (Phase 4)
    3. Test authentication flow end-to-end
    4. Archive or delete mock_db.json (optional)
    ```
  </action>
  <verify>
    Check documentations/migration-playbook.md exists with:
    - Pre-migration checklist
    - Step-by-step migration process
    - Multiple rollback options
    - Troubleshooting guide
    - Schema versioning info
  </verify>
  <done>Migration playbook created with rollback procedures and troubleshooting</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] Cloud Storage bucket created for backups
- [ ] Backup created successfully before migration
- [ ] Dry-run executed with no errors
- [ ] Actual migration executed successfully
- [ ] Data verified in Firebase Console (all collections present)
- [ ] tools/verify_migration.py passes all checks
- [ ] documentations/migration-playbook.md created
- [ ] Migration record exists in _migrations collection
- [ ] Document counts match mock_db.json
- [ ] Sample documents have correct schema and field names
</verification>

<success_criteria>
- All tasks completed
- Backup created and stored in Cloud Storage
- Migration executed successfully with no errors
- Data verified in Firebase Console
- Automated verification passes
- Rollback procedures documented
- Ready for Phase 4 (Backend Auth Refactor)
</success_criteria>

<output>
After completion, create `.planning/firebase-rbac-migration/phases/03-data-migration/03-02-SUMMARY.md`
</output>
